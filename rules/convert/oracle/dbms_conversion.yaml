name: "PostgreSQL â†’ Oracle PL/SQL ë³€í™˜"
description: "PostgreSQL Stored Procedureë¥¼ Oracle PL/SQLë¡œ ë¬¸ë²•ë§Œ ë³€í™˜"
version: "7.2"

path: "../dbms/{project_name}/{system_name}"

input_schema:
  required:
    - code
    - locale
  optional:
    parent_code:
      default: ""
      description: "ë¶€ëª¨ ì»¨í…ìŠ¤íŠ¸ (ì°¸ê³ ìš©, ë³€í™˜ ê²°ê³¼ì— í¬í•¨ ê¸ˆì§€)"

prompt: |
  ======================================================================
  ì ˆëŒ€ ê·œì¹™ (ìµœìš°ì„ )
  ======================================================================
  - ì „ë‹¬ëœ ì›ë³¸ SQLë¬¸ ì‹¤í–‰ê²°ê³¼ì™€ ì „í™˜ëœ SQLë¬¸ ì‹¤í–‰ê²°ê³¼ê°€ ê°™ì•„ì•¼ í•˜ë©´ì„œ ì›ë³¸ì„ ê°•ì œë¡œ ë”°ë¼í•  í•„ìš” ì—†ì´, ORACLE PLSQL ë¬¸ë²•ì— ë§ê²Œ ì‘ì„±  
  - PostgreSQLê³¼ Oracleì—ì„œ ë™ì¼í•œ ì…ë ¥ê°’ì„ ë„£ì—ˆì„ ë•Œ, ì¡°íšŒ/ì‚½ì…/ìˆ˜ì •/ì‚­ì œ ê²°ê³¼ê°€ 100% ë™ì¼í•´ì•¼ í•¨
  - ë¡œì§ì˜ ë³¸ì§ˆ(ëŒ€ìƒ í…Œì´ë¸” ë° í–‰, ì¡°ê±´, ê³„ì‚° ê²°ê³¼)ì€ ìœ ì§€í•˜ë˜, SQL/PLSQL ìŠ¤íƒ€ì¼Â·êµ¬ì¡°ëŠ” ììœ ë¡­ê²Œ ê°€ëŠ¥
  - ë³€í™˜ ê³¼ì •ì—ì„œ ë¶ˆí•„ìš”í•˜ê²Œ ë¼ì¸ì„ ëŠ˜ë¦¬ì§€ ë§ê³ , ì˜¤íˆë ¤ ë” ê°„ì†Œí™” ë° ì¤„ì´ëŠ” ìª½ìœ¼ë¡œ ì§„í–‰, ì¤„ë°”ê¿ˆë„ ì›ë³¸ì„ ë”°ë¼ê°€ë„ë¡ í•´ì„œ ë¼ì¸ ìˆ˜ë¥¼ ìœ ì§€ (ë‹¨! ê²°ê³¼ê°’ì€ ë™ì¼)
  - Parent ContextëŠ” ì°¸ê³ ìš©ì´ë©° ë³€í™˜ ê²°ê³¼ì— í¬í•¨í•˜ì§€ ì•ŠìŒ
  - ê²°ê³¼ë§Œ ë™ì¼í•˜ë‹¤ë©´ CTE/ì¡°ì¸ ë°©ì‹/ê³„ì‚°ì‹ ì •ë¦¬ ë“± ëª¨ë“  ë¦¬íŒ©í„°ë§ í—ˆìš©
  - month_cd = ''ì€ IS NULLì´ ì•„ë‹Œ month_cd = '.'ë¡œ ì „í™˜
  - ì „ë‹¬ëœ postgresql êµ¬ë¬¸ë§Œ ì „í™˜í•˜ê³ , ë¶€ê°€ì ì¸ ë‚´ìš©(CREATE OR REPLACE PROCEDURE ê°™ì€ ë‚´ìš©..)ì€ ì œì™¸í•  ê²ƒ, ë‹¹ì‹ ì€ procedure ë³¸ë¬¸ ë¡œì§ì„ ì „í™˜í•´ì•¼ í•©ë‹ˆë‹¤.
  - ì¤„ë°”ê¿ˆì€ ë˜ë„ë¡ì´ë©´ ì›ë³¸ì„ ë”°ë¼ê°€ë„ë¡ í•´ì„œ ë¼ì¸ ìˆ˜ë¥¼ ìœ ì§€í•˜ëŠ” ë°©í–¥ì„ ì¶”êµ¬í•˜ì„¸ìš”ìš” (ë‹¨! ê²°ê³¼ê°’ì€ ë™ì¼

  ======================================================================
  ì…ë ¥ ë°ì´í„°
  ======================================================================
  PostgreSQL SP ì½”ë“œ: {{code}}
  Parent Context (ì°¸ê³ ìš©): {{parent_code}}

  ======================================================================
  ğŸ”¥ SQL ìŠ¤íƒ€ì¼ ê·œì¹™ (ì•ì½¤ë§ˆ ê·œì¹™)
  ======================================================================
  **âš ï¸ ì•ì½¤ë§ˆ(Leading Comma)ë¥¼ ì ìš©í•  ìœ„ì¹˜ë§Œ ì—„ê²©íˆ ì œí•œ**

  **âœ… ì•ì½¤ë§ˆ ì ìš© ëŒ€ìƒ**
  - SELECT ì ˆ ì»¬ëŸ¼ ëª©ë¡
  - INSERT ì ˆ ì»¬ëŸ¼ ëª©ë¡
  - VALUES ì ˆ ê°’ ëª©ë¡
  - UPDATE ... SET ì ˆ ì»¬ëŸ¼ ëª©ë¡

  **âŒ ì•ì½¤ë§ˆ ì ìš© ì œì™¸**
  - í•¨ìˆ˜/í”„ë¡œì‹œì € í˜¸ì¶œ íŒŒë¼ë¯¸í„° ëª©ë¡
  - WHERE ì ˆ IN (...) ëª©ë¡
  - CASE WHEN ... THEN ... ëª©ë¡
  - ë‹¨ìˆœ ê°’ ë‚˜ì—´, ë¦¬í„°ëŸ´ ë‚˜ì—´

  **ì˜¬ë°”ë¥¸ ì˜ˆì‹œ**
  -- âœ… SELECT ì ˆ (ì•ì½¤ë§ˆ)
  SELECT col1, col2, col3
  FROM my_table;

  -- âœ… INSERT ì ˆ (ì•ì½¤ë§ˆ)
  INSERT INTO table_name (col1, col2, col3) VALUES (value1, value2, value3);

  -- âœ… UPDATE ì ˆ (ì•ì½¤ë§ˆ)
  UPDATE my_table
     SET col1 = val1
       , col2 = val2
   WHERE id = 100;

  ======================================================================
  ğŸ”„ WITH ì ˆ(CTE) ì‚¬ìš©/ë³€í™˜ ì§€ì¹¨ (Oracle í˜¸í™˜ì„± + ì„±ëŠ¥ ìµœì í™”) â€” ë²”ìš©Â·ì •êµ ì˜ˆì‹œ í¬í•¨
  ======================================================================

  ğŸ”¥ 1. ê¸°ë³¸ ì›ì¹™
  - Oracle SQLì—ì„œë„ WITH ì ˆ(Common Table Expression, CTE)ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ,
    SQL ë¬¸ì¥ ë‹¨ìœ„ë¡œ ì‘ì„±í•  ë•ŒëŠ” CTEë¥¼ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ëŠ” ê²ƒì„ ìš°ì„  ê³ ë ¤í•œë‹¤.
  - PL/SQL ë¸”ë¡ì—ì„œ DML(INSERT, UPDATE, DELETE, MERGE) ë˜ëŠ” SELECT INTO ì•ì— WITHë¥¼ ì“¸ ë•Œ
    ë¬¸ë²• ì œì•½ì´ ìˆëŠ” ê²½ìš°, ë™ì¼ ê²°ê³¼ê°€ ë˜ë„ë¡ FROM ì ˆ ì„œë¸Œì¿¼ë¦¬ë¡œ ë³€í™˜í•œë‹¤.
  - ëª©í‘œëŠ” â€œê²°ê³¼ ë™ì¼ì„±â€ì´ë©°, CTE ìœ ì§€ ë˜ëŠ” ì„œë¸Œì¿¼ë¦¬ ë³€í™˜ ì¤‘ ì–´ëŠ ìª½ì´ë“  ì„ íƒ ê°€ëŠ¥í•˜ë‹¤.
  - ë³€í™˜ ì‹œì—ëŠ” ì»¬ëŸ¼ëª…Â·ì¡°ê±´Â·ê³„ì‚°ì‹ì„ ì ˆëŒ€ ë³€ê²½í•˜ì§€ ì•Šê³ , êµ¬ì¡°ë§Œ ë°”ê¾¼ë‹¤.

  ğŸ”¥ 1-1. Oracle DML ë¬¸ë²• ê°•ì œ ê·œì¹™
  - Oracleì—ì„œëŠ” WITH ì ˆì„ ì‚¬ìš©í•  ë•Œ ë°˜ë“œì‹œ DML í‚¤ì›Œë“œ(INSERT, UPDATE, DELETE, MERGE) ë’¤ì— ë¶™ì—¬ì•¼ í•œë‹¤.
    ì˜ˆ:
      âœ… ì˜¬ë°”ë¥¸ ì˜ˆì‹œ
      INSERT INTO target_table (...)
      WITH cte1 AS (...), cte2 AS (...)
      SELECT ... FROM cte1 JOIN cte2 ON ... ;

      âŒ ì˜ëª»ëœ ì˜ˆì‹œ (PostgreSQL ìŠ¤íƒ€ì¼)
      WITH cte1 AS (...), cte2 AS (...)
      INSERT INTO target_table (...) SELECT ... ;

    â†’ ìœ„ êµ¬ì¡°ëŠ” Oracleì—ì„œ ORA-00928 ì˜¤ë¥˜ ë°œìƒ

  ğŸ”¥ 2. ê¶Œì¥ íŒ¨í„´
  - CTEê°€ ë³µì¡í•œ ê³„ì‚°ì„ ëª…í™•íˆ ë¶„ë¦¬í•´ ì£¼ê³  Oracleì—ì„œë„ ë¬¸ì œ ì—†ì´ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤ë©´ WITH ì ˆ ìœ ì§€.
  - CTEë¥¼ ìœ ì§€í•  ê²½ìš°, ê° CTE SELECT ëì— ì„¸ë¯¸ì½œë¡ ì„ ë¶™ì´ì§€ ë§ê³ , ë©”ì¸ DML/SELECTì™€ í•˜ë‚˜ì˜ ë¬¸ì¥ìœ¼ë¡œ ì‘ì„±.
  - PL/SQL ë¬¸ë²• ë•Œë¬¸ì— CTE ì‚¬ìš©ì´ ë¶ˆê°€ëŠ¥í•œ ìƒí™©ì—ì„œëŠ” FROM ì ˆ ì„œë¸Œì¿¼ë¦¬ë¡œ ì „í™˜.

  ğŸ”¥ 2-1. ì„±ëŠ¥ ìµœì í™” ì „ëµ (MATERIALIZE / INLINE)
  - PostgreSQLì˜ WITH CTEëŠ” í•œ ë²ˆ ê³„ì‚°ëœ ê²°ê³¼ë¥¼ ì¬ì‚¬ìš©í•˜ëŠ” ê²½í–¥ì´ ê°•í•˜ì§€ë§Œ,
    Oracleì˜ WITH CTEëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì¸ë¼ì¸ ë·°ì²˜ëŸ¼ ìµœì í™”ë˜ë©° ë™ì¼ CTEê°€ ì—¬ëŸ¬ ë²ˆ ì¬í‰ê°€ë  ìˆ˜ ìˆë‹¤.
  - ëŒ€ìš©ëŸ‰ í…Œì´ë¸”(JOIN + GROUP BY)ì´ë‚˜ ë³µì¡ VIEWë¥¼ í¬í•¨í•˜ëŠ” CTEëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì²˜ë¦¬í•œë‹¤.
    1. â€œë¹„ìš©ì´ í° CTEâ€ì—ëŠ” /*+ MATERIALIZE */ íŒíŠ¸ë¥¼ ìš°ì„  ê³ ë ¤
    2. â€œê°€ë²¼ìš´ CTEâ€ëŠ” íŒíŠ¸ ì—†ì´ ë‘ê±°ë‚˜ /*+ INLINE */ë¡œ ì¸ë¼ì¸ ìµœì í™” í—ˆìš©
    3. ì—¬ëŸ¬ ë²ˆ ì°¸ì¡°ë˜ê±°ë‚˜ ëŒ€ìš©ëŸ‰ ì§‘ê³„ â‡’ MATERIALIZE
    4. ë‹¨ì¼ ì°¸ì¡°Â·ë‹¨ìˆœ ë‚´ìš© â‡’ INLINE ë˜ëŠ” íŒíŠ¸ ì—†ìŒ

  ğŸ”¥ 2-2. ì„±ëŠ¥ ì˜ˆì™¸ ê·œì¹™
  - CTE ìœ ì§€ ì‹œ ì‹¤í–‰ ì‹œê°„ì´ ê³¼ë„í•˜ê²Œ ê¸¸ì–´ì§€ëŠ” ê²½ìš°(ëŒ€ìš©ëŸ‰Â·ë³µì¡ VIEWÂ·ë‹¤ì¤‘ ì°¸ì¡°)ì—ëŠ” ì„œë¸Œì¿¼ë¦¬ ë³€í™˜ í—ˆìš©
  - ë³€í™˜ ì‹œ ê²°ê³¼ ë™ì¼ì„± ìœ ì§€, ë¡œì§Â·ê³„ì‚°ì‹ ë™ì¼í•˜ê²Œ ì‘ì„±

  ğŸ“Œ 3. ë²”ìš© ì„œë¸Œì¿¼ë¦¬ ë³€í™˜ ì˜ˆì‹œ
  - ì»¬ëŸ¼ëª…Â·í…Œì´ë¸”ëª…ì€ ì˜ì–´ë¡œ ë²”ìš©í™”, êµ¬ì¡°ëŠ” ì‹¤ì œ ì—…ë¬´ ì˜ˆì‹œì™€ ë™ì¼
  - ì›ë³¸ CTE êµ¬ì¡°ë¥¼ ê·¸ëŒ€ë¡œ ë°˜ì˜í•˜ë˜, FROM ì ˆ ì„œë¸Œì¿¼ë¦¬ë¡œ ë³€í™˜

  INSERT /*+ monitor */ INTO target_table (
      month_cd, apply_month, plant_code, process_code, resource_code,
      category1, category2, category3, category4, product_code, grade_group, brand_code,
      mix_ratio, usage_qty, unit_std, unit_price, cost_amt, created_dt, type_flag, seq_no
  )
  SELECT
      p_month_cd,
      p_apply_month,
      p_plant_code,
      'CC',
      MAT.resource_code,
      CODE.category1,
      CODE.category2,
      CODE.category3,
      CODE.category4,
      MAT.product_code,
      MAT.grade_group,
      CODE.brand_code,
      CASE WHEN CODE.category4 NOT LIKE 'C04%' THEN
          COALESCE(MAT.plan_usage_qty / NULLIF((
              SELECT prod_qty
              FROM view_prod_qty
              WHERE month_cd = MAT.month_cd
                AND apply_month = MAT.apply_month
                AND resource_code = MAT.resource_code
                AND product_code = MAT.product_code
                AND grade_group = MAT.grade_group
          ),0),0)
      ELSE 0 END AS mix_ratio,
      COALESCE(MAT.plan_usage_qty / NULLIF((
          SELECT prod_qty * EXTRACT(DAY FROM LAST_DAY(TO_DATE(MAT.apply_month,'YYYYMM')))
          FROM view_prod_qty
          WHERE resource_code = MAT.resource_code
            AND month_cd = '.'
            AND product_code = MAT.product_code
            AND grade_group = MAT.grade_group
      ),0),0) * (
          SELECT plan_qty
          FROM view_plan_qty
          WHERE month_cd = MAT.month_cd
            AND apply_month = MAT.apply_month
            AND resource_code = MAT.resource_code
            AND product_code = MAT.product_code
            AND grade_group = MAT.grade_group
      ) AS usage_qty,
      COALESCE(MAT.plan_usage_qty / NULLIF((
          SELECT prod_qty * EXTRACT(DAY FROM LAST_DAY(TO_DATE(MAT.apply_month,'YYYYMM')))
          FROM view_prod_qty
          WHERE resource_code = MAT.resource_code
            AND month_cd = '.'
            AND product_code = MAT.product_code
            AND grade_group = MAT.grade_group
      ),0),0) * 1000 AS unit_std,
      DECODE(NVL(MAT.unit_price,0),0,P.unit_price,MAT.unit_price) * 1000 AS unit_price,
      (DECODE(NVL(MAT.unit_price,0),0,P.unit_price,MAT.unit_price) * 1000) *
      COALESCE(MAT.plan_usage_qty / NULLIF((
          SELECT prod_qty * EXTRACT(DAY FROM LAST_DAY(TO_DATE(MAT.apply_month,'YYYYMM')))
          FROM view_prod_qty
          WHERE resource_code = MAT.resource_code
            AND month_cd = '.'
            AND product_code = MAT.product_code
            AND grade_group = MAT.grade_group
      ),0),0) AS cost_amt,
      SYSDATE,
      'R',
      CODE.seq_no
  FROM (
      SELECT
          B.brand_code AS brand_code,
          p_apply_month AS apply_month,
          p_month_cd AS month_cd,
          CASE WHEN A.brand_code = 'BRAND1' THEN (
              SELECT cost_amt/1000 FROM table_cost
              WHERE month_cd = p_month_cd AND apply_month = p_apply_month
                AND plant_code = p_plant_code AND process_code = 'BF'
                AND resource_code = 'ALL' AND category4 = 'B0101' AND type_flag = 'R'
          )
          WHEN B.brand_code = 'BRAND2' THEN (
              SELECT cost_amt/1000 FROM table_cost
              WHERE month_cd = p_month_cd AND apply_month = p_apply_month
                AND plant_code = p_plant_code AND process_code = 'FN'
                AND resource_code = 'ALL' AND category4 = 'B0101' AND type_flag = 'R'
          )
          ELSE A.unit_price END AS unit_price,
          COALESCE(B.day_qty,0) * EXTRACT(DAY FROM LAST_DAY(TO_DATE(p_apply_month,'YYYYMM'))) AS plan_usage_qty,
          B.resource_code,
          B.product_code,
          B.grade_group,
          B.category4
      FROM (
          SELECT
              a.seq_no, a.month_cd, a.plant_code, a.apply_month, a.brand_code,
              COALESCE(b.total_stock_unit_price,a.unit_price) AS unit_price, a.type_flag
          FROM table_base a
          LEFT JOIN table_stock_price b
            ON a.month_cd = b.month_cd
          AND a.apply_month = b.stock_month
          AND a.plant_code = b.plant_code
          AND a.brand_code = b.item
          AND a.type_flag = b.pred_flag
          WHERE a.month_cd = p_month_cd
            AND a.plant_code = p_plant_code
            AND a.apply_month = p_apply_month
            AND a.type_flag = 'R'
      ) A
      RIGHT JOIN (
          SELECT
              x.brand_code,
              x.resource_code,
              x.product_code,
              x.grade_group,
              x.category3,
              x.category4,
              SUM(x.usage_qty)/MAX(y.total_work_day) AS day_qty
          FROM table_large x
          JOIN view_work_day y
            ON x.plant_code = y.plant_code
          AND x.day_cd = y.day_cd
          AND x.process_code = y.process_code
          AND x.resource_code = y.resource_code
          AND x.product_code = y.product_code
          AND x.grade_group = y.grade_group
          WHERE x.data_type = 'M'
            AND x.process_code = 'CC'
            AND x.category4 LIKE 'C%'
            AND x.category4 <> 'C0111'
          GROUP BY x.plant_code, x.category3, x.category4, x.resource_code, x.product_code, x.grade_group, x.brand_code
      ) B
        ON A.brand_code = B.brand_code
      WHERE B.resource_code IS NOT NULL
  ) MAT
  LEFT JOIN (
      SELECT DISTINCT
          c1.category1, c1.category2, c1.category3, c1.category4, c2.brand_code, c1.seq_no
      FROM table_category c1
      LEFT JOIN table_brand_map c2
        ON c2.category4 = c1.category4
      WHERE c1.flag_use = 'Y'
  ) CODE
    ON MAT.brand_code = CODE.brand_code
  AND MAT.category4 = CODE.category4
  LEFT JOIN (
      SELECT
          a.plant_code, a.category4, a.brand_code,
          COALESCE(SUM(a.usage_qty * a.unit_price) / NULLIF(SUM(a.usage_qty),0),0) / 1000 AS unit_price
      FROM table_large a
      JOIN (
          SELECT MAX(day_cd) AS day_cd, plant_code, category4, brand_code
          FROM table_large
          WHERE day_cd <= p_month_cd
            AND category4 LIKE 'C%'
            AND category4 <> 'C0111'
            AND data_type = 'M'
            AND plant_code = p_plant_code
          GROUP BY plant_code, category4, brand_code
      ) b
        ON a.day_cd = b.day_cd
      AND a.plant_code = b.plant_code
      AND a.category4 = b.category4
      AND a.brand_code = b.brand_code
      WHERE a.process_code = 'CC'
      GROUP BY a.plant_code, a.category4, a.brand_code
  ) P
    ON MAT.category4 = P.category4
  AND MAT.brand_code = P.brand_code
  WHERE MAT.apply_month = p_apply_month;

  â†’ ìœ„ ì˜ˆì‹œëŠ” ì›ë³¸ CTE êµ¬ì¡°ë¥¼ ê·¸ëŒ€ë¡œ ë°˜ì˜í•˜ë˜, ì»¬ëŸ¼ëª…Â·í…Œì´ë¸”ëª…Â·íŒŒë¼ë¯¸í„°ëª…ì„ ì˜ì–´ë¡œ ë²”ìš©í™”í•œ ì„œë¸Œì¿¼ë¦¬ ë³€í™˜ ì˜ˆì‹œì´ë‹¤.



  ======================================================================
  ğŸ“ DML êµ¬ë¬¸ ì²˜ë¦¬ (PL/SQL í•„ìˆ˜ ê·œì¹™)
  ======================================================================
  **ğŸ”¥ 1. ì„¸ë¯¸ì½œë¡ (;) í•„ìˆ˜**
  - ëª¨ë“  INSERT, UPDATE, DELETE, SELECT INTO ë¬¸ ëì—ëŠ” ë°˜ë“œì‹œ `;` ì¶”ê°€
  - SELECT INTOëŠ” PL/SQL ë¬¸ì¥ì´ë¯€ë¡œ í•­ìƒ ì„¸ë¯¸ì½œë¡ ìœ¼ë¡œ ì¢…ë£Œ
  - ì„œë¸Œì¿¼ë¦¬ê°€ ëë‚œ ì§í›„ ë°”ë¡œ ë‹¤ë¥¸ PL/SQL ë¬¸(DBMS_OUTPUT, IF, LOOP ë“±)ì´ ì´ì–´ì§€ëŠ” ê²½ìš° ì„¸ë¯¸ì½œë¡  ëˆ„ë½ ì£¼ì˜

  -- ì˜ëª»ëœ ì˜ˆì‹œ
  INSERT INTO table1 (...)
  SELECT ...
    FROM some_table
   WHERE ...       -- â† ì„¸ë¯¸ì½œë¡  ì—†ìŒ
  DBMS_OUTPUT.PUT_LINE('ì™„ë£Œ');

  -- ì˜¬ë°”ë¥¸ ì˜ˆì‹œ
  INSERT INTO table1 (...)
  SELECT ...
    FROM some_table
   WHERE ...;
  DBMS_OUTPUT.PUT_LINE('ì™„ë£Œ');

  ======================================================================
  [MERGE ë³€í™˜ ê³µí†µ ì§€ì¹¨] â€“ ë²”ìš© MERGE íŒ¨í„´ (ë‹¨ì¼ ì„¹ì…˜)
  ======================================================================

  [1] ëª©ì 

  - PostgreSQL ì˜ UPDATE / MERGE / ë³µì¡ SELECT ë¡œì§ì„
    Oracle MERGE ë¬¸ìœ¼ë¡œ ë³€í™˜í•  ë•Œ ì‚¬ìš©í•  **ë‹¨ì¼ ê³µí†µ íŒ¨í„´**ì„ ì •ì˜í•œë‹¤.
  - ì´ íŒ¨í„´ì€ íŠ¹ì • ì—…ë¬´(mod_qty, v_base ë“±)ì— ì¢…ì†ë˜ì§€ ì•ŠëŠ”ë‹¤.
  - ì˜ˆì‹œì˜ ëª¨ë“  ì´ë¦„(ì»¬ëŸ¼ëª…, ë³€ìˆ˜ëª…, í…Œì´ë¸”ëª…, ìƒìˆ˜ê°’)ì€ â€œì—­í•  ì„¤ëª…ìš©(generic)â€ì´ë©°,
    ì‹¤ì œ ì½”ë“œì—ì„œëŠ” ë°˜ë“œì‹œ ì›ë³¸ ìŠ¤í‚¤ë§ˆ/ì—…ë¬´ ìš©ì–´ì— ë§ê²Œ ë³€ê²½í•´ì•¼ í•œë‹¤.


  [2] MERGE ì „ì²´ ê³¨ê²© (ë°˜ë“œì‹œ ì´ í‹€ì„ ì‚¬ìš©)

    merge into <schema>.<target_table> tx
    using (
        select
              k_key1
            , k_key2
            , k_key3
            , k_attr1
            , k_attr2
            , k_group
            , base_qty             -- ê¸°ì¤€/ì´ëŸ‰
            , round(calc_value1, 5)                                   as out_value1
            , round(
                  decode(
                      base_divisor1, 0, base_amount1,
                      decode(calc_value1, 0, 0, base_amount1 * calc_value1 / base_divisor1)
                  )
              , 5)                                                     as out_value2
            , round(
                  decode(calc_value1, 0, 0, calc_value1 / sum_calc_value1)
              , 10)                                                    as out_ratio1
            , round(
                  decode(calc_value1, 0, 0, calc_value1 / base_qty) * scale_factor
              , 10)                                                    as out_ratio2
        from (
            -- ë‚´ë¶€ SELECT: ì›ë³¸/ë³´ì¡° í…Œì´ë¸” ê²°í•© + ê³„ì‚° ë¡œì§
            <INNER_SELECT_BLOCK>
        ) src
    ) vx
    on (
          1 = 1
      and tx.k_key1  = vx.k_key1
      and tx.k_key2  = vx.k_key2
      and tx.k_key3  = vx.k_key3
      and tx.k_attr1 = vx.k_attr1
      and tx.k_attr2 = vx.k_attr2
      and tx.k_group = vx.k_group
      and tx.fix_flag1 = <ìƒìˆ˜ê°’1>   -- ì˜ˆ: 'ì£¼ì›ë£Œ'
      and tx.fix_flag2 = <ìƒìˆ˜ê°’2>   -- ì˜ˆ: 'R'
    )
    when matched then
        update set
              tx.target_col1 = vx.out_value1
            , tx.target_col2 = vx.out_value2
            , tx.target_col3 = vx.out_ratio1
            , tx.target_col4 = vx.out_ratio2
    ;

  í•„ìˆ˜ ê·œì¹™:

  - USING ì ˆ ì•ˆì—ëŠ” **SELECT í•œ ê°œ**ë§Œ ë‘”ë‹¤.
  - ON ì ˆì€ í•­ìƒ `1 = 1`ë¡œ ì‹œì‘í•˜ê³ , ë’¤ì— í‚¤ ì»¬ëŸ¼ ë§¤ì¹­ + ìƒìˆ˜ ì¡°ê±´ì„ ë‚˜ì—´í•œë‹¤.
  - UPDATE SET ìš°ë³€ì—ëŠ” **í•­ìƒ vxì—ì„œ aliasë¡œ ê³„ì‚°í•œ ì»¬ëŸ¼(out_*)ë§Œ** ì‚¬ìš©í•œë‹¤.
  - `calc_value1`, `base_divisor1`, `base_amount1`, `sum_calc_value1`, `base_qty`, `scale_factor`
    ë“±ì€ INNER_SELECT_BLOCK ì—ì„œ ê³„ì‚°Â·ì§€ì •í•œë‹¤.


  [3] INNER_SELECT_BLOCK íŒ¨í„´ (ì¤‘ì²© êµ¬ì¡°ì™€ JOIN)

  INNER_SELECT_BLOCK ëŠ” ë‹¤ìŒ êµ¬ì¡°ë¥¼ ê¸°ë³¸ìœ¼ë¡œ í•œë‹¤.

    select
          t_base.k_key1
        , t_base.k_key2
        , t_base.k_key3
        , t_base.k_attr1
        , t_base.k_attr2
        , t_base.k_group
        , t_base.base_divisor1      -- ì˜ˆ: ê¸°ì¤€ ì‚¬ìš©ëŸ‰
        , t_base.base_amount1       -- ì˜ˆ: ê¸°ì¤€ ê¸ˆì•¡
        , t_metric.base_qty         -- ì˜ˆ: ì œí’ˆ/ì´ëŸ‰
        , nvl(v_calc.calc_value1, 0)                                   as calc_value1
        , sum(nvl(v_calc.calc_value1, 0))
          over (
            partition by
                  t_base.k_key1
                , t_base.k_key2
                , t_base.k_key3
                , t_base.k_attr1
                , t_base.k_attr2
                , t_base.k_group
          )                                                            as sum_calc_value1
        , <í•„ìš”ì‹œ ì¶”ê°€ ê¸°ì¤€/ì¤‘ê°„ ê³„ì‚° ì»¬ëŸ¼ë“¤>
    from (
        -- ì¡°ì •/ê³„ì‚° ë¡œì§ì„ ëª¨ì€ ì„œë¸Œì¿¼ë¦¬
        <CALC_SUBQUERY>
    ) v_calc
    , <ê¸°ë³¸ í…Œì´ë¸”> t_base
    , (
        -- ê¸°ì¤€ ìˆ˜ëŸ‰/ê¸ˆì•¡ì„ ì œê³µí•˜ëŠ” ì„œë¸Œì¿¼ë¦¬
        <METRIC_SUBQUERY>
    ) t_metric
    where 1 = 1
      -- v_calc ì™€ t_base ë§¤ì¹­ (í•„ìš”ì‹œ OUTER JOIN)
      and t_base.k_key1  = v_calc.k_key1(+)
      and t_base.k_key2  = v_calc.k_key2(+)
      and t_base.k_key3  = v_calc.k_key3(+)
      and t_base.k_attr1 = v_calc.k_attr1(+)
      and t_base.k_attr2 = v_calc.k_attr2(+)
      and t_base.k_group = v_calc.k_group(+)
      -- t_metric ê³¼ t_base ë§¤ì¹­ (ì¼ë°˜ì ìœ¼ë¡œ INNER JOIN)
      and t_base.k_key1  = t_metric.k_key1
      and t_base.k_key2  = t_metric.k_key2
      and t_base.k_key3  = t_metric.k_key3
      and t_base.k_attr1 = t_metric.k_attr1
      and t_base.k_attr2 = t_metric.k_attr2
      and t_base.k_group = t_metric.k_group
      -- íŒŒë¼ë¯¸í„° í•„í„° (ì¼ì/ì›”/ê³µì¥ ë“±)
      and t_base.k_key1  = p_param1
      and t_base.k_key2  = p_param2
      and t_base.k_key3  = p_param3
      -- êµ¬ë¶„/ìœ í˜• í•„í„°
      and t_base.fix_flag1 = <ìƒìˆ˜ê°’1>
      and t_base.fix_flag2 = <ìƒìˆ˜ê°’2>
      -- ê¸°íƒ€ ì œì™¸ ì¡°ê±´
      and nvl(t_base.exclude_flag, 'N') != 'Y';

  ê·œì¹™:

  - FROM ì ˆì˜ ìµœìƒìœ„ êµ¬ì¡°ëŠ” í•­ìƒ  
    `(CALC_SUBQUERY) v_calc, ê¸°ë³¸ t_base, (METRIC_SUBQUERY) t_metric`  
    í˜•íƒœë¥¼ ë”°ë¥¸ë‹¤.
  - WHERE ì ˆì€ `where 1 = 1`ë¡œ ì‹œì‘í•˜ê³ ,  
    1) JOIN ì¡°ê±´ â†’ 2) íŒŒë¼ë¯¸í„° ì¡°ê±´ â†’ 3) ìœ í˜•/ì½”ë“œ ì¡°ê±´ â†’ 4) ì œì™¸ ì¡°ê±´ ìˆœìœ¼ë¡œ ë‚˜ì—´í•œë‹¤.


  [4] CALC_SUBQUERY íŒ¨í„´ (ë³µì¡ ê³„ì‚°/ì¡°ì • ë¡œì§ ëª¨ìŒ)

  CALC_SUBQUERY ëŠ” â€œì—¬ëŸ¬ ë‹¨ê³„ì˜ ê³„ì‚°ê³¼ ìœˆë„ìš° í•¨ìˆ˜â€ë¥¼ ëª¨ì€ ë¸”ë¡ì´ë‹¤.  
  êµ¬ì²´ ì´ë¦„ì€ ììœ ì§€ë§Œ, ì•„ë˜ì™€ ê°™ì´ **3ë‹¨ê³„ ì •ë„ë¡œ ìª¼ê°  í˜•íƒœ**ë¥¼ ê¶Œì¥í•œë‹¤.

    (
      select
            s_outer.k_key1
          , s_outer.k_key2
          , s_outer.k_key3
          , s_outer.k_attr1
          , s_outer.k_attr2
          , s_outer.k_group
          , s_outer.k_code
          , s_outer.base_value1
          , case
              when <íŠ¹ì • ì½”ë“œ/ê·¸ë£¹ ì¡°ê±´1>
                then s_outer.adjusted_main_value
              when <íŠ¹ì • ì½”ë“œ/ê·¸ë£¹ ì¡°ê±´2>
                then case when s_outer.diff_value1 > 0 then s_outer.diff_value1 else 0 end
              when <íŠ¹ì • ì½”ë“œ/ê·¸ë£¹ ì¡°ê±´3>
                then case
                      when s_outer.diff_value1 < 0 then s_outer.base_value1 - s_outer.diff_value1
                      else s_outer.base_value1
                    end
              else s_outer.base_value1
            end                                             as calc_value1
      from (
          select
                s_mid.k_key1
              , s_mid.k_key2
              , s_mid.k_key3
              , s_mid.k_attr1
              , s_mid.k_attr2
              , s_mid.k_group
              , s_mid.k_code
              , s_mid.base_value1
              , s_mid.tot_in_value
              , s_mid.tot_out_value
              , s_mid.adjusted_main_value
              , s_mid.adjusted_total_value
              , s_mid.total_org_value
              , sum(
                    case
                      when <ì¡°ì • ëŒ€ìƒ ì½”ë“œ ì¡°ê±´>
                        then s_mid.base_value1 + s_mid.diff_value1
                      else 0
                    end
                ) over (
                    partition by
                          s_mid.k_key1
                        , s_mid.k_key2
                        , s_mid.k_key3
                        , s_mid.k_attr1
                        , s_mid.k_attr2
                        , s_mid.k_group
                )                                          as diff_value1
          from (
              select
                    b.k_key1
                  , b.k_key2
                  , b.k_key3
                  , b.k_attr1
                  , b.k_attr2
                  , b.k_group
                  , b.k_code
                  , decode(b.base_value1,  0, 1, b.base_value1)       as base_value1
                  , decode(b.tot_in_value, 0, 1, b.tot_in_value)      as tot_in_value
                  , decode(b.tot_out_value,0, 1, b.tot_out_value)     as tot_out_value
                  , case
                      when <ê¸°ì¤€ ì½”ë“œ ì¡°ê±´>
                        then b.base_value1 * (b.tot_in_value / b.tot_out_value)
                      else 0
                    end                                        as adjusted_main_value
                  , sum(
                      case
                        when <ê¸°ì¤€ ì½”ë“œ ì¡°ê±´>
                          then b.base_value1 * (b.tot_in_value / b.tot_out_value)
                        else 0
                      end
                    ) over (
                        partition by
                              b.k_key1
                            , b.k_key2
                            , b.k_key3
                            , b.k_attr1
                            , b.k_attr2
                            , b.k_group
                    )                                          as adjusted_total_value
                  , max(b.org_sum_value)
                    over (
                        partition by
                              b.k_key1
                            , b.k_key2
                            , b.k_key3
                            , b.k_attr1
                            , b.k_attr2
                            , b.k_group
                    )                                          as total_org_value
                  , max(b.org_sum_value)
                    over (
                        partition by
                              b.k_key1
                            , b.k_key2
                            , b.k_key3
                            , b.k_attr1
                            , b.k_attr2
                            , b.k_group
                    )
                    - sum(
                        case
                          when <ê¸°ì¤€ ì½”ë“œ ì¡°ê±´>
                            then b.base_value1 * (b.tot_in_value / b.tot_out_value)
                          else 0
                        end
                      ) over (
                        partition by
                              b.k_key1
                            , b.k_key2
                            , b.k_key3
                            , b.k_attr1
                            , b.k_attr2
                            , b.k_group
                      )                                        as diff_value1
              from (
                  select
                        t.k_key1
                      , t.k_key2
                      , t.k_key3
                      , t.k_attr1
                      , t.k_attr2
                      , t.k_group
                      , t.k_code
                      , t.base_value1
                      , v_inout.tot_in_value
                      , v_inout.tot_out_value
                      , case
                          when <ì§‘ê³„ ëŒ€ìƒ ì½”ë“œ ê·¸ë£¹ ì¡°ê±´>
                            then sum(t.base_value1) over (
                                partition by
                                      t.k_key1
                                    , t.k_key2
                                    , t.k_key3
                                    , t.k_attr1
                                    , t.k_attr2
                                    , t.k_group
                                    , <ì½”ë“œ ê·¸ë£¹ í‘œí˜„ì‹>
                              )
                          else 0
                        end                                   as org_sum_value
                  from <ì›ë³¸ í…Œì´ë¸”> t
                    , <ì…ì¶œëŸ‰/ê³„íš/ë‹¨ê°€ ì§‘ê³„ ì„œë¸Œì¿¼ë¦¬> v_inout
                  where 1 = 1
                    and t.k_key1  = p_param1
                    and t.k_key2  = p_param2
                    and t.k_key3  = p_param3
                    and t.attr_filter1 = <ìƒìˆ˜/ì¡°ê±´>
                    and t.attr_filter2 = <ìƒìˆ˜/ì¡°ê±´>
                    and t.k_key1  = v_inout.k_key1(+)
                    and t.k_key2  = v_inout.k_key2(+)
                    and t.k_key3  = v_inout.k_key3(+)
                    and t.k_code  = v_inout.k_code(+)
                    and nvl(t.exclude_flag, 'N') != 'Y'
              ) b
          ) s_mid
      ) s_outer
    ) v_calc

  í•µì‹¬:

  - alias ì´ë¦„(s_outer, s_mid, b ë“±)ì€ ì˜ˆì‹œì¼ ë¿ì´ë©°, ììœ ë¡­ê²Œ ë³€ê²½ ê°€ëŠ¥í•˜ë‹¤.
  - ê°™ì€ alias ì´ë¦„ì„ ì¤‘ë³µí•´ì„œ ì‚¬ìš©í•˜ì§€ ë§ ê²ƒ
  - **ì¤‘ìš”í•œ ê²ƒì€ êµ¬ì¡°ì™€ ì—°ì‚° íŒ¨í„´**ì´ë‹¤:
    - ê°€ì¥ ì•ˆìª½ì—ì„œ ì›ë³¸ + ë³´ì¡°ê°’ì„ JOINí•˜ê³ ,
    - ì¤‘ê°„ ë ˆë²¨ì—ì„œ ìœˆë„ìš° í•©ê³„/ìµœëŒ€/ì°¨ì´ê°’(diff)ì„ ê³„ì‚°í•˜ê³ ,
    - ê°€ì¥ ë°”ê¹¥ì—ì„œ ì½”ë“œ/ê·¸ë£¹ë³„ CASE ë¡œ ìµœì¢… calc_value1ì„ ë§Œë“ ë‹¤.
  - ë¶„ëª¨ê°€ ë˜ëŠ” ê°’(tot_out_value ë“±)ì€ decode/nullif ë¡œ 0 ë³´í˜¸ë¥¼ ë°˜ë“œì‹œ í•œë‹¤.


  [5] METRIC_SUBQUERY íŒ¨í„´ (ê¸°ì¤€ ìˆ˜ëŸ‰/ê¸ˆì•¡ ì œê³µ)

  METRIC_SUBQUERY ëŠ” ê¸°ì¤€ ìˆ˜ëŸ‰/ê¸ˆì•¡ì„ ì œê³µí•˜ëŠ” ì„œë¸Œì¿¼ë¦¬ì´ë‹¤.

    (
      select
            m_key1     as k_key1
          , m_key2     as k_key2
          , m_key3     as k_key3
          , m_attr1    as k_attr1
          , m_attr2    as k_attr2
          , m_group    as k_group
          , metric_qty as base_qty
      from <ê¸°ì¤€ í…Œì´ë¸” ë˜ëŠ” ì§‘ê³„ ë·°>
      where 1 = 1
        and m_key1  = p_param1
        and m_key2  = p_param2
        and m_key3  = p_param3
        and m_filter1 = <ìƒìˆ˜/ì¡°ê±´>
        and m_filter2 = <ìƒìˆ˜/ì¡°ê±´>
    ) t_metric


  [6] ê´„í˜¸, ì„œë¸Œì¿¼ë¦¬, alias ì‚¬ìš© ê·œì¹™ (ìš°ê´„í˜¸ ì˜¤ë¥˜ ë°©ì§€)

  - ëª¨ë“  ì„œë¸Œì¿¼ë¦¬ëŠ” ì•„ë˜ í˜•ì‹ë§Œ ì‚¬ìš©í•œë‹¤.

    from (
        select ...
        from ...
        where ...
    ) alias

  - `from(` ì²˜ëŸ¼ `from`ê³¼ `(`ë¥¼ ë¶™ì´ì§€ ì•ŠëŠ”ë‹¤.  
    í•­ìƒ `from (` ë’¤ì— ì¤„ë°”ê¿ˆ, ë‹¤ìŒ ì¤„ì— `select` ê°€ ì˜¨ë‹¤.

    ì˜ëª»ëœ ì˜ˆ:
      from(select ...
    ì˜¬ë°”ë¥¸ ì˜ˆ:
      from (
          select ...

  - í•œ ì¤„ ì•ˆì— `from ( select ... from ( select ...` ë¥¼ ì—¬ëŸ¬ ë²ˆ ì¤‘ì²©í•˜ì§€ ì•ŠëŠ”ë‹¤.  
    ê° ë ˆë²¨ë§ˆë‹¤ `) alias` ë¡œ ëª…í™•íˆ ë‹«ê³ , ë‹¤ìŒ from ì„ ì‹œì‘í•œë‹¤.

  - INNER_SELECT_BLOCK ì˜ ìµœìƒìœ„ FROM êµ¬ì¡°ëŠ” í•­ìƒ

    from (
        <CALC_SUBQUERY>
    ) v_calc
    , <ê¸°ë³¸ í…Œì´ë¸”> t_base
    , (
        <METRIC_SUBQUERY>
    ) t_metric

    í˜•íƒœë¡œ í†µì¼í•œë‹¤. ì´ íŒ¨í„´ì„ ë²—ì–´ë‚˜ëŠ” í˜¼í•© ì‘ì„±ì€ ê¸ˆì§€í•œë‹¤.


  [7] ì´ë¦„/ì»¬ëŸ¼/ë³€ìˆ˜ì— ëŒ€í•œ ì›ì¹™
  - ì‹¤ì œ ë³€í™˜ ì‹œì—ëŠ” ë°˜ë“œì‹œ PostgreSQL ì›ë³¸ ì½”ë“œì˜ ì»¬ëŸ¼ëª…/í…Œì´ë¸”ëª…/ë³€ìˆ˜ëª…ì„ ê¸°ì¤€ìœ¼ë¡œ ë§¤í•‘í•œë‹¤.

  ======================================================================
  ğŸ—ï¸ DDL ë° ë™ì  SQL ì²˜ë¦¬
  ======================================================================
  - PL/SQL ë‚´ DDLì€ EXECUTE IMMEDIATE ì‚¬ìš©
  - DROP/CREATE/ALTER/TRUNCATE ë“±ì€ ë¬¸ìì—´ë¡œ ê°ì‹¸ EXECUTE IMMEDIATE ì‹¤í–‰

  ======================================================================
  ğŸš¨ ì˜ˆì™¸ ì²˜ë¦¬ ë° ì¶œë ¥
  ======================================================================
  - RAISE NOTICE â†’ DBMS_OUTPUT.PUT_LINE
  - RAISE EXCEPTION â†’ RAISE_APPLICATION_ERROR(-20001, 'message')
  - ë¡œê·¸ ë©”ì‹œì§€ëŠ” ììœ ë¡­ê²Œ êµ¬ì„± ê°€ëŠ¥ (ê²°ê³¼ì— ì˜í–¥ ì—†ë„ë¡)

  ======================================================================
  ğŸ”„ í”„ë¡œì‹œì € í˜¸ì¶œ ë° ìŠ¤í‚¤ë§ˆ ì²˜ë¦¬
  ======================================================================
  - PostgreSQLì˜ CALL ë¬¸ì€ ì œê±°í•˜ê³  `schema.proc(args);` í˜•íƒœë¡œ ë³€í™˜
  - ìŠ¤í‚¤ë§ˆ ì ‘ë‘ì‚¬ëŠ” ì›ë³¸ê³¼ ë™ì¼í•˜ê²Œ ìœ ì§€

  ======================================================================
  ğŸ”— JOIN êµ¬ë¬¸ í‘œì¤€í™”
  ======================================================================
  - LEFT JOIN â†’ LEFT OUTER JOIN
  - RIGHT JOIN â†’ í…Œì´ë¸” ìˆœì„œ ì¡°ì • + LEFT OUTER JOIN
  - FULL JOIN â†’ FULL OUTER JOIN
  - Legacy `(+)` ì‚¬ìš© ì‹œ ë°©í–¥ ì •í™•íˆ ìœ ì§€ (í•„ìš” ì‹œ ANSI JOINìœ¼ë¡œ ì „í™˜ ê°€ëŠ¥í•˜ë‚˜ ê²°ê³¼ ë™ì¼ì„± ê²€ì¦)
  - ì¡°ì¸ ìˆœì„œëŠ” ë³€ê²½ ê°€ëŠ¥í•˜ë‚˜ ê²°ê³¼ê°€ ë™ì¼í•´ì•¼ í•¨

  ======================================================================
  ğŸ”— ìµœì¢… ê²€ì¦
  ======================================================================
  Oracle ìµœì í™” ììœ ë„ vs ê²°ê³¼ ë™ì¼ì„±

  PostgreSQL ì›ë¬¸ì€ â€œì°¸ê³  ìë£Œâ€ì¼ ë¿ì…ë‹ˆë‹¤. Oracle í™˜ê²½ì—ì„œ ê°€ì¥ ì•ˆì •ì ì´ê³  ì„±ëŠ¥ ì¢‹ì€ ë°©ì‹ìœ¼ë¡œ ë§ˆìŒê» ì¬êµ¬ì„±í•˜ì„¸ìš”.
  ë‹¨, ì–´ë–¤ í˜•íƒœë¡œ ì“°ë”ë¼ë„ ì¡°íšŒÂ·ì‚½ì…Â·ìˆ˜ì •Â·ì‚­ì œ ëŒ€ìƒ í–‰ê³¼ ê°’ì´ 1:1ë¡œ ë™ì¼í•´ì•¼ í•©ë‹ˆë‹¤.
  â€œêµ¬ì¡° ë³µì œâ€ê°€ ì•„ë‹ˆë¼ â€œê²°ê³¼ ë³µì œâ€ê°€ ëª©ì ì„ì„ ëª…ì‹¬í•˜ì‹­ì‹œì˜¤.
  CTE(With) ì‚¬ìš© ì‹œ í•„ìˆ˜ ì²´í¬

  WITH ë¸”ë¡ì€ ë‹¨ì¼ DML/SELECT ë¬¸ì¥ ì•ì— ë¶™ì—¬ ì‘ì„±í•˜ê³ , ë‚´ë¶€ SELECTì—ëŠ” ì„¸ë¯¸ì½œë¡ ì„ ë„£ì§€ ì•ŠìŠµë‹ˆë‹¤.
  PL/SQL ë¸”ë¡ì—ì„œ ë¬¸ë²• ì œì•½ì´ ìˆìœ¼ë©´ EXECUTE IMMEDIATE í˜¹ì€ ë™ì¼ ê²°ê³¼ ì„œë¸Œì¿¼ë¦¬ë¡œ ì¦‰ì‹œ ì „í™˜í•©ë‹ˆë‹¤.
  ê° CTEëŠ” aliasì™€ ì»¬ëŸ¼ ìˆœì„œë¥¼ ëª…í™•íˆ ì§€ì •í•˜ê³ , í•œ WITH ë¸”ë¡ ì•ˆì— ë³µìˆ˜ DMLì„ ì„ì§€ ë§ˆì‹­ì‹œì˜¤.
  ìµœì¢… í™•ì¸ ì²´í¬ë¦¬ìŠ¤íŠ¸

  [ ] ëª¨ë“  DML/SELECT INTO ë’¤ì— ì„¸ë¯¸ì½œë¡ ì´ ìˆëŠ”ê°€?
  [ ] CTEê°€ ìˆë‹¤ë©´ ë‹¨ì¼ ë¬¸ì¥ë§Œ í¬í•¨í•˜ë©° Oracle ë¬¸ë²•ì„ ìœ„ë°˜í•˜ì§€ ì•ŠëŠ”ê°€?
  [ ] í•¨ìˆ˜/í”„ë¡œì‹œì € ì¸ì ê°œìˆ˜ê°€ ì›ë³¸ê³¼ 100% ë™ì¼í•œê°€?
  [ ] ì›ë³¸ê³¼ ë™ì¼í•œ í–‰ì´ ì¡°íšŒÂ·ì‚½ì…Â·ìˆ˜ì •Â·ì‚­ì œë˜ëŠ”ì§€ ìƒ˜í”Œë¡œ ê²€ì¦í–ˆëŠ”ê°€?
  âœ… ìš”ì•½: Oracle ìŠ¤íƒ€ì¼ë¡œ ë¦¬íŒ©í„°ë§í•˜ë˜, ë°ì´í„° ê²°ê³¼ê°€ 1ì°¨ SPì™€ ì™„ì „íˆ ê°™ë„ë¡ ê²€ì¦í•˜ê³ , CTE ì‚¬ìš© ì‹œ Oracle ë¬¸ë²• ê°€ë“œë ˆì¼ì„ ë°˜ë“œì‹œ ì¤€ìˆ˜í•˜ì‹­ì‹œì˜¤.
 
  ======================================================================
  ì¶œë ¥ í˜•ì‹
  ======================================================================
  ì•„ë˜ JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•  ê²ƒ:
  {
    "code": "ë³€í™˜ëœ Oracle PL/SQL SP ì „ì²´ ì½”ë“œ ë¬¸ìì—´"
  }