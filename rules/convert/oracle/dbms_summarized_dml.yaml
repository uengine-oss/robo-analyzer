name: "PostgreSQL DML Oracle 스켈레톤 생성"
description: "PostgreSQL 요약 DML 블록을 Oracle 문법으로만 변환하되 자식 placeholder는 그대로 유지"
version: "2.8"

input_schema:
  required:
    - summarized_code
    - locale

prompt: |
  당신은 PostgreSQL DML을 Oracle PL/SQL용 DML 스켈레톤으로 변환하는 전문가입니다.

  summarized_postgresql_dml_code:
  {{summarized_code}}

  ======================================================================
  🔥 핵심 원칙 (진짜로 중요한 건 이것뿐)
  ======================================================================
  1) summarized_code 안에서 **부모(Parent) DML 구문(INSERT, UPDATE, DELETE, SELECT, MERGE, WITH 등)**만 Oracle 표준 문법으로 변환한다.
  2) **자식(Child) placeholder `숫자: ...code...` 라인은 어떤 글자도 바꾸지 말고, 입력에 나온 그대로 반환한다.**
     - 숫자, 콜론(:), 공백, `...code...` 내용 모두 한 글자도 수정 금지
     - summarized_code에 등장한 placeholder 개수와 번호가 출력에도 그대로 유지되어야 한다.
     - 새로운 placeholder를 만들거나 기존 placeholder를 복제해서 하나 더 찍어내면 안 된다.

  요약하면:
  **“부모 구문만 Oracle로 바꾸고, 자식 placeholder는 그대로 복붙해서 돌려준다.”**

  ======================================================================
  🔧 부모 / 자식 처리 방식
  ======================================================================
  - 부모 라인 예시:
    - `9: INSERT INTO tgt_table (col1, col2, col3)`
    - `20: UPDATE tgt SET col = 1`
    - `23: UPDATE legacy_order tgt SET order_state = 'READY' FROM ( 26: ...code... ) aud`
    이런 라인은 Oracle 문법에 맞게 재작성 대상이다.
    - 번호와 콜론(`9:`, `20:`, `23:`)은 그대로 두고, 뒤에 오는 SQL만 Oracle 스타일로 바꾼다.
    - 컬럼/인자 나열은 되도록 한 줄에 유지한다.  
      예: `INSERT INTO tgt_table (col1, col2, col3)`

  - 자식 placeholder 라인 예시:
    - `10: ...code...`
    - `21: ...code...`
    - `26: ...code...`
    이런 라인은 **절대 수정하지 않고 그대로 출력**한다.
    - 괄호나 USING, JOIN 안으로 넣을 때는 **줄바꿈해서 가독성 있게 배치**해도 되지만,
      줄 안의 텍스트(`숫자: ...code...`)는 그대로여야 한다.
      예:
        USING (
          26: ...code...
        ) aud

  ======================================================================
  🔥 예시 (최소한, 명확하게)
  ======================================================================
  - 예시 A (INSERT, 컬럼은 한 줄 / 자식은 그대로 별도 라인):
    입력:
      `9: INSERT INTO tgt_table (col1, col2, col3)`
      `10: ...code...`
    출력:
      `9: INSERT INTO tgt_table (col1, col2, col3)`
      `10: ...code...`

  - 예시 B (단순 UPDATE 그대로 유지, 자식은 별도 라인):
    입력:
      `20: UPDATE tgt SET col = 1`
      `21: ...code...`
    출력:
      `20: UPDATE tgt SET col = 1`
      `21: ...code...`

  - 예시 C (UPDATE ... FROM → MERGE, 인자 한 줄 / ...code는 줄바꿈):
    입력:
      `23: UPDATE legacy_order tgt SET order_state = 'READY' FROM ( 26: ...code... ) aud`
    출력:
      `23: MERGE INTO legacy_order tgt`
      `      USING (`
      `        26: ...code...`
      `      ) aud`
      `      WHEN MATCHED THEN UPDATE SET order_state = 'READY';`

  위 예시는 “패턴”만 보여주는 것이며, 실제 변환 시에도
  **부모는 Oracle 문법으로 변환, 자식 placeholder는 텍스트 그대로(단, 괄호 안에 넣을 때는 줄바꿈만)**라는 원칙만 지키면 된다.

  ======================================================================
  🔍 최종 점검
  ======================================================================
  - 부모 DML 구문만 Oracle 표준 문법으로 변환했는가?
  - `숫자: ...code...` 형태의 자식 placeholder 라인은 입력과 글자 단위까지 완전히 동일한가?
  - placeholder의 번호와 개수가 입력과 출력에서 100% 일치하는가?
  - 새로운 placeholder를 만들지 않았는가?
  - 기존 placeholder를 복제해서 두 번 이상 찍지 않았는가?

  ======================================================================
  🔥 최종 출력 형식
  ======================================================================
  - 반드시 다음 JSON 구조로만 출력한다:
    {
      "code": "Oracle 변환된 전체 스켈레톤 코드"
    }
