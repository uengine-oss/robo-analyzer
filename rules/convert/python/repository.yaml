# Repository 클래스 생성 Role
# 타겟: SQLAlchemy Repository

name: "Repository 클래스 생성"
description: "DML 노드를 SQLAlchemy Repository 메서드로 변환"
version: "1.0"

# 저장 경로 정의
path: "repository"

# 입력 스키마
input_schema:
  required:
    - entity_name           # Entity 클래스명 (PascalCase)
    - repository_nodes      # DML 코드 리스트 (JSON 문자열)
    - used_variable_nodes   # 사용된 변수 정보 (JSON 문자열)
    - count                 # 생성할 메서드 수
    - global_variable_nodes # 전역 변수 정보 (JSON 문자열)
    - locale                # 언어 설정

# 프롬프트
prompt: |
  당신은 클린 아키텍처 원칙을 따르는 파이썬 애플리케이션을 개발하는 소프트웨어 엔지니어입니다. 
  주어진 데이터를 기반으로 SQLAlchemy를 사용한 Repository 메서드를 생성하는 작업을 맡았습니다.
  
  사용자 언어 설정 : {{locale}}, 입니다. 이를 반영하여 결과를 생성해주세요.
  
  Stored Procedure Code:
  {{repository_nodes}}
  
  
  Used Variable:
  {{used_variable_nodes}}
  
  
  Global Variable:
  {{global_variable_nodes}}
  
  
  생성될 Repository 메서드는 {{count}}개입니다.
  'Global Variable'들은 애플리케이션 전반에서 전역적으로 사용되는 변수들로 필요한 경우 활용하세요.
  
  
  [SECTION 1] SQLAlchemy Repository 메서드 생성 지침
  ===============================================
  1. 변환 범위
     - 각 JSON 객체는 독립적으로 Repository 메서드로 변환
     - ...code... 표시된 부분은 제외하고 변환
  
  2. 변환 규칙
     - 각 JSON 객체는 자신의 Stored Procedure Code만 참조
     - 다른 객체의 코드는 참고하지 않음
     - 엔티티 명명 규칙: 단수형 파스칼 케이스 (예: Employee)
     - 메서드 명명 규칙: find_by_*, get_*, count_*, save_* 등 (스네이크 케이스)
  
  3. 매개변수 처리
     - 'Used Variable' 목록의 모든 변수는 메서드 매개변수로 포함
     - 누락된 매개변수 없이 완전한 매핑 필요
     - 'Used Variable'에 명시되지 않은 변수라도 SP 코드에서 식별되면 적절한 타입으로 매개변수화
  
  4. 동일한 Repository 메서드 처리
     - 서로 다른 객체에서 쿼리가 같을 경우 똑같은 Repository 메서드로 보세요
     - 별도로 'method'를 생성하지말고 똑같은 'method'의 'range'에 범위만 추가하세요
     
    
  5. 시퀀스 처리
     - 'Stored Procedure Code'에서 시퀀스 사용 패턴 식별:
       * [시퀀스명].NEXTVAL 패턴 검색
       * SELECT [시퀀스명].NEXTVAL FROM DUAL 구문 식별
       * INSERT 문에서 VALUES 절에 [시퀀스명].NEXTVAL 사용 확인
       * 테이블 컬럼에 시퀀스 할당되는 패턴 검색 (예: table_column = [시퀀스명].NEXTVAL)
       * 시퀀스 사용이 발견되면 해당 시퀀스명을 추출하여 get_next_[시퀀스명] 형태의 조회 메서드 생성
     - 시퀀스 사용 위치 파악하여 해당 엔티티의 어떤 필드에 사용되는지 'field' 항목에 명시
     - 시퀀스 메서드 명명 규칙: get_next_[시퀀스명]
     - 반환 타입은 int로 통일
     - 예시: "def get_next_sequence(self) -> int:\\n    result = self.session.execute(text(\"SELECT SAMPLE_SEQ.NEXTVAL FROM DUAL\"))\\n    return result.scalar()"
  
  
  [SECTION 2] Repository 메서드 필수 구현 규칙
  ===============================================
  1. 반환 타입 규칙
     - SELECT 단건 조회: Optional[엔티티명]
     - SELECT 목록 조회: List[엔티티명]
     - COUNT 조회: int
     - 엔티티 이름은 전달된 테이블 명을 그대로 파스칼 케이스로 전환하여 사용하세요. (예: TPJ_EMPLOYEE -> TpjEmployee)
  
  2. 읽기 전용 원칙
     - 모든 쿼리는 SELECT 문으로만 변환
     - UPDATE/INSERT/DELETE 문도 SELECT 문으로 변환하여 데이터 조회
     - 예시:
       * UPDATE 문의 경우: 업데이트할 데이터를 먼저 조회
       * 입력: "UPDATE Users SET name = 'John' WHERE id = 1"
       * 변환: "SELECT * FROM Users WHERE id = 1"
     
     - INSERT 문의 경우: 삽입할 데이터의 중복 체크를 위한 조회
     - DELETE 문의 경우: 삭제할 데이터를 먼저 조회
     - 데이터 변경 작업은 서비스 레이어에서 구현
     예시:
        employee = employee_repository.find_by_id(id)
        employee.status = new_status
        employee_repository.save(employee)
  
  3. 복잡한 쿼리 처리
     - 복잡한 조건문의 경우 text() 함수를 사용한 원시 SQL 쿼리 실행
     - 파라미터 바인딩은 콜론(:) 사용
     - 예시: session.execute(text("SELECT * FROM tpj_employee WHERE emp_key = :emp_key"), {"emp_key": emp_key})
  
  4. 날짜 기간 처리
     - TRUNC 함수 사용 금지
     - 타입은 반드시 date 타입으로 통일
     - 시작일자(start_date)와 종료일자(end_date) 매개변수 사용
     - BETWEEN 절을 통한 기간 필터링
     
  
  [SECTION 3] Repository 메서드 작성 예시
  ===============================================
  출력 형식:
  - 클래스 정의는 제외하고 메서드만 포함
  - self 매개변수는 항상 포함
  - 순수 메서드만 'method'에 포함
  - 'method' 필드는 반드시 메소드 시그니처와 구현부를 개행문자(\\n)로 구분하여 포함해야 합니다
  
  예시 출력:
  def find_by_emp_key(self, emp_key: int) -> Optional[TpjEmployee]:\\n    return self.session.query(TpjEmployee).filter(TpjEmployee.emp_key == emp_key).first()
  
  
  [SECTION 4] JSON 출력 형식
  ===============================================
  부가 설명 없이 결과만을 포함하여, 다음 JSON 형식으로 반환하세요:
  {
      "analysis": [
          {
              "tableName": "원본 테이블 명(예: TPJ_EMPLOYEE)",
              "method": "def method_name(self, param1: type, param2: type) -> ReturnType:\\n    return self.session.query(Entity).filter(Entity.column == param1).all()",
              "range": [
                 {
                    "startLine": 시작라인번호,
                    "endLine": 끝라인번호,
                 },
              ]
          }
      ],
      "seq_method": [
          {
           "method": "def get_next_sequence(self) -> int:\\n    result = self.session.execute(text(\"SELECT SEQ.NEXTVAL FROM DUAL\"))\\n    return result.scalar()",
           "field": "필드명",
          }
      ]
  }