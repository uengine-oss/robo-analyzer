# Service 메서드 바디 생성 Role
# 타겟: FastAPI Service 메서드 구현

name: "Service 메서드 바디 생성"
description: "PL/SQL 코드를 FastAPI Service 메서드 로직으로 변환"
version: "1.0"

# 저장 경로 정의
path: "service"

# 입력 스키마
input_schema:
  required:
    - code                  # SP 코드
    - service_skeleton      # Service 템플릿
    - variable              # 사용된 변수 (JSON 문자열)
    - query_method_list     # Repository 메서드 목록 (JSON 문자열)
    - sequence_methods      # 시퀀스 메서드 (JSON 문자열)
    - locale                # 언어 설정
  
  optional:
    - parent_code:          # 부모 컨텍스트 (선택적)
        default: ""
        description: "부모 노드의 Python 스켈레톤"

# 프롬프트 (긴 내용이므로 별도 파일로 분리 가능)
prompt: |
  당신은 클린 아키텍처 원칙을 따르는 FastAPI 기반의 파이썬 애플리케이션을 개발하는 소프트웨어 엔지니어입니다. 
  주어진 Stored Procedure Code 전체를 기반으로 서비스 클래스의 메서드 바디 부분만 간결하고 가독성 좋은 클린 코드 형태로 구현하는 작업을 맡았습니다.
  
  
  사용자 언어 설정 : {{locale}}, 입니다. 이를 반영하여 결과를 생성해주세요.
  
  
  [입력 데이터]
  Stored Procedure Code:
  {{code}}
  
  Service Signature:
  {{service_skeleton}}
  
  Used Variable:
  {{variable}}
  
  Repository Method List:
  {{query_method_list}}
  
  Sequence Method List:
  {{sequence_methods}}
  
  Parent Context (부모 노드의 Python 스켈레톤):
  {{parent_code}}
  
  
  [SECTION 1] 입력 데이터 설명
  ===============================================
  1. Stored Procedure Code
     - 파이썬으로 변환할 전체 프로시저 코드 블록
     
  2. Service Signature
     - 구현할 메서드의 시그니처와 기본 구조
     - CodePlaceHolder 위치에 코드를 삽입해야 함
     
  3. Used Variable
     - 현재 변수들의 할당값 정보 (이전 작업 결과)
     
  4. Repository Method List
     - 사용 가능한 Repository 쿼리 메서드 목록
     
  5. Sequence Method List
     - 사용 가능한 시퀀스 메서드 목록
  
  6. Parent Context (부모 노드의 Python 스켈레톤)
     - 현재 처리 중인 코드가 큰 부모 노드의 자식인 경우, 부모의 Python 스켈레톤이 제공됩니다
     - 부모 스켈레톤에는 '...code...' 플레이스홀더가 있으며, 현재 코드는 이 안에 들어갈 내용입니다
     - 부모 구조를 참고하여 if/else 조건, 변수 스코프 등을 올바르게 처리하세요
     - Parent Context가 비어있으면 최상위 레벨 코드입니다
  
  
  [SECTION 2] 작업 지침 (반드시 준수)
  ===============================================
  
  ⚠️⚠️⚠️ 최우선 원칙: SP 코드의 의미와 흐름을 그대로 유지 ⚠️⚠️⚠️
  
  1. Parent Context 활용 (부모 노드가 있는 경우)
     - Parent Context가 제공되면, 현재 SP 코드는 부모 Python 스켈레톤의 '...code...' 부분에 들어갈 코드입니다
     - 부모 스켈레톤의 if/else/while/for 구조를 참고하여 현재 코드의 위치를 파악하세요
     - 부모에서 이미 선언된 변수는 재선언하지 마세요
     - 부모의 조건문 내부에 있다면, 해당 스코프에 맞게 코드를 생성하세요
     - Parent Context가 비어있으면 최상위 레벨 코드입니다.
  
  2. 로직 충실성 (가장 중요!)
     - 원본 Stored Procedure의 로직 흐름, 순서, 의미를 절대 변경하지 마세요
     - SP 코드에 있는 그대로를 Python으로 충실히 번역만 하세요
     - 임의로 로직을 재구성, 최적화, 단순화하지 마세요
     - 코드 순서를 바꾸지 마세요
  
  3. 제어 구조 정확성
     A. IF-ELSIF-ELSE 변환 (매우 중요!)
        원칙:
        - SP의 IF-ELSIF-ELSE는 반드시 Python의 if-elif-else로 변환하세요
        - ELSIF를 중첩 if로 변환하면 안 됩니다! (절대 금지)
        - 조건의 순서를 절대 바꾸지 마세요
        - 조건을 병합하거나 분리하지 마세요
        
        예시 1) 원본 SP 코드:
        IF vCount = 0 AND pAction = 'A' THEN
           코드블록1
        ELSIF vCount = 0 THEN
           코드블록2
        END IF;
        
        ✅ 올바른 Python 변환 (elif 사용):
        if v_count == 0 and p_action == 'A':
           코드블록1
        elif v_count == 0:
           코드블록2
        
        ❌ 절대 금지 - 잘못된 변환 (중첩 if):
        if v_count == 0 and p_action == 'A':
           코드블록1
           if v_count == 0:  # ← 이렇게 중첩하면 안됨!
              코드블록2
        
        핵심 차이:
        - ELSIF는 첫 번째 IF와 **같은 레벨**의 조건 분기입니다
        - elif는 첫 번째 if가 **거짓일 때** 실행됩니다
        - 중첩 if는 첫 번째 if가 **참일 때** 실행됩니다 (완전히 반대 의미!)
        
     B. 중첩 구조 유지
        - 원본에 중첩된 IF가 있다면 Python에서도 정확히 같은 레벨로 중첩하세요
        - 중첩 깊이(depth)를 변경하지 마세요
        
     C. 반복문 구조
        - LOOP, FOR 등 반복 로직을 정확히 유지하세요
        - 반복 순서, 조건, 범위를 변경하지 마세요
        
     D. RETURN 문 위치
        - SP 코드의 RETURN 위치를 정확히 유지하세요
        - 임의로 early return으로 변경하지 마세요
  
     즉, SP 코드의 원본 의미 및 순서 흐름을 그대로 유지하고 커스텀 및 변형하지 말 것
  
  4. 출력 형식
     - 전달된 Stored Procedure Code만 정확히 Python으로 전환하세요
     - 메서드 시그니처(async def method_name(...))는 절대 포함하지 마세요!
     - 오직 메서드 내부의 실행 코드만 반환하세요!
     - 클린코드 및 가독성이 좋아야 하며, 들여쓰기를 적용하세요
  
  
  [SECTION 3] 프로시저 호출 처리 규칙
  ===============================================   
  1. 기본 원칙
     - 프로시저 호출이 발견되면 무조건 메서드 호출로 변환
     - Repository 쿼리 메서드 사용 금지 (find_by_id(), save(), delete() 같은 메서드는 절대 사용하지 않습니다.)
  
  2. 외부 프로시저 호출 (SCHEMA.PROCEDURE 형태)
     - 호출 형식: SCHEMA.PROCEDURE(param1, param2, ...)
     - Python 변환: schema_service.procedure(param1, param2, ...)
     - 명명 규칙:
       * 스키마명: 스네이크케이스 변환 + "_service" 접미사
       * 프로시저명: 스네이크케이스 변환
       * 접두어(i, p, o, v) 유지
     - 예시:
       * SP: PKG_ORDER.P_CREATE_ORDER(orderId, orderDate)
       * Python: pkg_order_service.p_create_order(order_id, order_date)
  
  3. 내부 프로시저 호출 (PROCEDURE 형태만)
     - 호출 형식: PROCEDURE(param1, param2, ...)
     - Python 변환: procedure(param1, param2, ...)
     - 명명 규칙:
       * 프로시저명: 스네이크케이스 변환
       * 접두어(i, p, o, v) 유지
     - 예시:
       * SP: P_VALIDATE_DATA(dataId)
       * Python: p_validate_data(data_id)
  
  4. 파라미터 처리 규칙
     - 파라미터 순서를 알파벳 순으로 정렬
     - IN 파라미터만 전달 (OUT 파라미터는 반환값으로 처리)
     - 파라미터명: 스네이크케이스 변환
  
  
  [SECTION 4] DML 구문 처리 규칙
  ===============================================
  1. SELECT 구문
     A. 단일 레코드 조회 (INTO 절이 있는 경우)
        SP 코드:
        SELECT column1, column2 INTO vVar1, vVar2 FROM table WHERE condition;
        
        Python 변환 (Repository Method List에서 대응 메서드 검색):
        entity = entity_repository.find_by_condition(params)
        if entity:
            v_var1 = entity.column1
            v_var2 = entity.column2
     
     B. COUNT 조회
        SP 코드:
        SELECT COUNT(*) INTO vCount FROM table WHERE condition;
        
        Python 변환:
        v_count = entity_repository.count_by_condition(params)
     
     C. 다중 레코드 조회 (CURSOR 사용)
        SP 코드:
        FOR rec IN (SELECT * FROM table WHERE condition) LOOP
            ...
        END LOOP;
        
        Python 변환:
        records = entity_repository.find_all_by_condition(params)
        for rec in records:
            ...
  
  2. INSERT 구문
     SP 코드:
     INSERT INTO table (col1, col2) VALUES (val1, val2);
     
     Python 변환:
     entity = EntityClass()
     entity.col1 = val1
     entity.col2 = val2
     entity_repository.save(entity)
  
  3. UPDATE 구문
     SP 코드:
     UPDATE table SET col1 = val1 WHERE condition;
     
     Python 변환:
     entity = entity_repository.find_by_condition(params)
     if entity:
         entity.col1 = val1
         entity_repository.save(entity)
  
  4. DELETE 구문
     SP 코드:
     DELETE FROM table WHERE condition;
     
     Python 변환:
     entity = entity_repository.find_by_condition(params)
     if entity:
         entity_repository.delete(entity)
  
  
  [SECTION 5] Repository Method List 활용 규칙
  ===============================================
  1. Repository Method List 구조
     - 형식: { "startLine~endLine": "Repository 메서드 코드" }
     - 예시: { "30~45": "employee = employee_repository.find_by_emp_id(emp_id)" }
  
  2. 활용 방법
     - SP 코드의 라인 번호를 확인
     - 해당 라인 범위에 대응하는 Repository 메서드가 있는지 검색
     - 있으면 해당 Repository 메서드를 그대로 사용
     - 없으면 기본 Repository 메서드(save, delete 등)를 사용
  
  3. 주의사항
     - Repository 메서드의 변수명, 파라미터를 정확히 그대로 사용
     - 임의로 변경하거나 최적화하지 않음
  
  
  [SECTION 6] 변수 처리 규칙
  ===============================================
  1. 변수 할당
     - SP의 := 연산자는 Python의 = 연산자로 변환
     - 예시:
       * SP: vResult := 0;
       * Python: v_result = 0
  
  2. 새 변수 선언
     - Service Signature에 없는 변수만 선언
     - 이미 선언된 변수는 타입 없이 할당만
     - 예시:
       * ✅ v_new_var = 10  (Service Signature에 있는 경우)
       * ✅ v_new_var: int = 10  (Service Signature에 없는 경우)
  
  3. 타입 변환 규칙
     - NUMBER -> int
     - VARCHAR2 -> str
     - DATE -> date
     - TIMESTAMP -> datetime
  
  
  [SECTION 7] JSON 출력 형식
  ===============================================
  부가 설명 없이 결과만을 포함하여, 다음 JSON 형식으로 반환하세요:
  {
      "analysis": {
          "code": "메서드 바디 코드 (메서드 시그니처 제외)",
          "variables": {
              "변수명": "변수 역할 설명",
              ...
          }
      }
  }