# 괄호 복구를 위한 SQL 분해 프롬프트

input_schema:
  required:
    - broken_sql
    - open_count
    - close_count
    - locale

prompt: |
  역할
  - 당신은 Oracle SQL 괄호 구조 분석 전문가입니다.

  현재 상황
  - 여는 괄호 '(' 개수: {{ open_count }}개
  - 닫는 괄호 ')' 개수: {{ close_count }}개
  - 괄호 불일치로 인해 SQL 실행이 불가능합니다.

  목표
  - SQL을 구문 단위로 분해하여 각 조각의 괄호 구조를 완전하게 만들어야 합니다.
  - 분해된 조각들을 재조립하면 완전한 SQL이 됩니다.

  분해 규칙
  1. 부모-자식 관계로 SQL을 계층적으로 분해합니다.
  2. 부모 구문은 스켈레톤(뼈대) 형식으로 만들고, 자식이 들어갈 위치는 "{{CHILD_N}}" 형태의 플레이스홀더로 표시합니다.
  3. **중요**: 플레이스홀더는 반드시 정확히 "{{CHILD_1}}", "{{CHILD_2}}" 형식을 사용하세요 (중괄호 2개씩).
  4. CHILD 번호는 1부터 순차적으로 증가해야 합니다 (누락 없이).
  5. 각 분해 조각은 독립적으로 괄호가 완전히 매칭되어야 합니다.
  6. 세미콜론(;)은 원래 위치에만 포함시킵니다.
  7. 주석은 유지합니다.
  8. 원본 SQL의 의미와 구조를 절대 변경하지 않습니다.

  분해 예시
  원본: INSERT INTO t1 SELECT * FROM (SELECT a, b FROM t2 WHERE c > 0) WHERE d = 1;
  
  분해 결과:
  [PARENT]
  INSERT INTO t1 SELECT * FROM {{CHILD_1}} WHERE d = 1;
  
  [CHILD_1]
  (SELECT a, b FROM t2 WHERE c > 0)

  입력 SQL (괄호 불완전):
  ```sql
  {{ broken_sql }}
  ```

  출력 형식
  - 반드시 JSON 형식으로 출력하세요.
  - code 필드에 분해 결과를 포함하세요.
  - [PARENT], [CHILD_1], [CHILD_2] ... 형태로 분해된 조각을 출력하세요.
  - 각 조각은 괄호가 완전히 매칭되어야 합니다.
  - 플레이스홀더는 정확히 {{CHILD_N}} 형식으로 작성하세요.

  응답 형식:
  {
    "code": "[PARENT]\n...\n\n[CHILD_1]\n...\n\n[CHILD_2]\n..."
  }

