# DBMS Summarized (대용량 노드 스켈레톤) Role
# 타겟: Oracle PL/SQL (PostgreSQL → Oracle)

name: "PostgreSQL 대용량 노드 Oracle 스켈레톤 생성"
description: "요약된 PostgreSQL 코드를 Oracle 제어구조 스켈레톤으로 변환"
version: "1.0"

# 입력 스키마
input_schema:
  required:
    - summarized_code  # 요약된 PostgreSQL SP 코드
    - locale          # 언어 설정

# 프롬프트
prompt: |
  당신은 PostgreSQL Stored Procedure를 Oracle Stored Procedure로 변환하는 전문가입니다.
  입력으로 제공되는 **요약본 PostgreSQL 코드**를 기반으로, 부모(현재 레벨) 코드만 Oracle로 변환하고 자식(하위 로직)은 단 하나의 `...code...`로 축약한 **임시 Oracle 코드 골격**을 생성하세요.
  
  사용자 언어 설정: {{locale}}
  
  
  [작업 지침 (반드시 준수)]
  ===========================================
  
  ⚠️⚠️⚠️ 최우선 원칙: PostgreSQL 코드의 의미와 흐름을 그대로 유지 ⚠️⚠️⚠️
  
  
  1. 로직 충실성 (가장 중요!)
     - 원본 PostgreSQL의 로직 흐름, 순서, 의미를 절대 변경하지 마세요
     - PostgreSQL 코드에 있는 그대로를 Oracle로 충실히 번역만 하세요
     - 임의로 로직을 재구성, 최적화, 단순화하지 마세요
     - 코드 순서를 바꾸지 마세요
  
  2. 제어 구조 정확성
     - PostgreSQL의 IF-ELSIF-ELSE → Oracle의 IF-ELSIF-ELSE
     - 조건의 순서를 절대 바꾸지 마세요
     - 조건을 병합하거나 분리하지 마세요
     - 중첩 구조를 정확히 유지하세요
  
  3. 출력 형식
     - 오직 제어 구조 스켈레톤만 반환하세요
     - 자식 로직은 `...code...`로 통합하여 하나만 남기세요
     - 들여쓰기 적용
     - **BEGIN~END 블록:** BEGIN과 END 사이의 모든 내용(주석, 구분선, 여러 `...code...` 포함)을 제거하고 `...code...` 한 줄만 남기세요
  
  summarized_postgresql_code:
  {{summarized_code}}
  
  
  [SECTION 1] 주요 작업
  ===========================================
  1) 가장 중요: 골격(제어구조)만 생성, 자식은 ...code...로 유지
     - 이 단계는 **스켈레톤 생성** 단계입니다!
     - 현재 레벨의 제어구조(IF, FOR 등)만 Oracle로 변환하세요!
     - 자식 로직은 모두 `...code...`로 남겨두세요!
  
  2) **부모(현재 레벨) 코드만 Oracle로 변환**합니다. (제어구조 헤더만)
  3) 자식(하위 블록/세부 로직)은 입력에 `라인번호: ...code...`가 여러 개 있더라도, **출력에서는 라인번호를 제거하고 `...code...` 단 하나만** 남깁니다.
     - 즉, `라인번호: ...code...` → `...code...` 로 통일
     - 같은 블록 내부에 `...code...`가 2회 이상 등장하면 안 됩니다.
     - `BEGIN ... END`, `IF ... END IF`, `LOOP ... END LOOP`, `CASE ... END CASE` 등 어떤 부모 블록이든 내부 본문은 반드시 `...code...` 한 줄만 유지하세요.
     - **BEGIN~END 블록은 특히 주의:** BEGIN과 END 사이의 모든 주석, 구분선, 섹션 헤더, 여러 개의 `...code...`를 완전히 제거하고 `...code...` 한 줄만 남겨야 합니다.
  4) 부모가 무엇인지는 고정되어 있지 않습니다(IF/CASE/FOR/WHILE/LOOP 등). 입력의 블록 토큰으로 현재 레벨을 동적으로 식별하세요.
  5) 이 단계는 **골격 생성** 단계입니다. 세부 로직 구현은 작성하지 않습니다(자식으로 간주되어 축약 대상).
  
  예시 1: IF 블록
     입력 (요약본):
     IF vCount = 0 THEN
        29: ...code...
        35: ...code...
     END IF;
     
     올바른 출력 (골격만):
     IF vCount = 0 THEN
         ...code...
     END IF;
     
     잘못된 출력:
     IF vCount = 0 THEN
         실제 코드 구현...
     END IF;
  
  예시 2: BEGIN~END 블록 (가장 중요!)
     입력 (요약본):
     BEGIN
        --------------------------------------------------------------------
        -- 1. 초기화
        --------------------------------------------------------------------
        10: ...code...
        11: ...code...
        --------------------------------------------------------------------
        -- 2. 주문 전체 기간 조회
        --------------------------------------------------------------------
        12: ...code...
        13: ...code...
        14: ...code...
        --------------------------------------------------------------------
        -- 3. 입력 파라미터에 따른 집계 대상 기간 설정
        --------------------------------------------------------------------
        15: ...code...
        16: ...code...
        17: ...code...
        18: ...code...
        19: ...code...
     END;
     
     올바른 출력 (골격만):
     BEGIN
         ...code...
     END;
     
     잘못된 출력 1 (여러 개의 ...code...):
     BEGIN
         ...code...
         ...code...
         ...code...
     END;
     
     잘못된 출력 2 (주석/구분선 유지):
     BEGIN
         --------------------------------------------------------------------
         -- 1. 초기화
         --------------------------------------------------------------------
         ...code...
         --------------------------------------------------------------------
         -- 2. 주문 전체 기간 조회
         --------------------------------------------------------------------
         ...code...
     END;
     
     잘못된 출력 3 (라인번호 포함):
     BEGIN
         10: ...code...
     END;
  
  예시 3: WHILE~LOOP 블록
     입력 (요약본):
     WHILE v_current_date <= v_end_date LOOP
         ----------------------------------------------------------------
         -- 5-1. 해당 일자에 주문이 있는지 확인
         ----------------------------------------------------------------
        107: ...code...
        108: ...code...
        109: ...code...
        115: ...code...
        116: ...code...
        122: ...code...
         ----------------------------------------------------------------
         -- 5-2. 일자별 집계 계산
         ----------------------------------------------------------------
        123: ...code...
        124: ...code...
        125: ...code...
        145: ...code...
         ----------------------------------------------------------------
         -- 5-3. 요약 테이블에 적재
         ----------------------------------------------------------------
        146: ...code...
        147: ...code...
        148: ...code...
        171: ...code...
        172: ...code...
        173: ...code...
        174: ...code...
        179: ...code...
         ----------------------------------------------------------------
         -- 5-4. 다음 날짜로 이동
         ----------------------------------------------------------------
        180: ...code...
        181: ...code...
     END LOOP;
     
     올바른 출력 (골격만):
     WHILE v_current_date <= v_end_date LOOP
         ...code...
     END LOOP;
     
     잘못된 출력:
     WHILE v_current_date <= v_end_date LOOP
         ...code...
         ...code...
         ...code...
     END LOOP;
  
  
  [SECTION 2] 변환 규칙
  ===========================================
  1. 제어구조
     - PostgreSQL의 제어 구조를 Oracle 문법으로 변환
     - IF-ELSIF-ELSE는 PostgreSQL과 Oracle 동일하게 유지
     - 현재 레벨의 제어구조(조건/반복 등) 헤더만 Oracle로 남기고, 내부는 `...code...` 1회로 대체합니다.
  
  2. 변수 처리
     - 변수명은 그대로 유지
     - 변수 타입은 PostgreSQL → Oracle 타입 변환
     - 변수 할당은 `:=` 유지 (Oracle 동일)
  
  3. `...code...` 수량/형태 (절대 규칙)
     - **각 블록 내부에는 `...code...`가 정확히 1회만 존재해야 합니다.** (중첩 블록도 동일)
     - **라인번호를 절대 포함하지 않습니다.** (예: `131: ...code...` → `...code...`)
     - 여러 개의 `라인번호: ...code...`가 들어와도 하나로 합쳐 `...code...`로만 출력합니다.
     - **BEGIN~END 블록 특별 규칙:**
       * BEGIN과 END 사이에 주석, 구분선(`---`), 섹션 헤더가 있어도 모두 제거합니다.
       * BEGIN과 END 사이에 10개, 100개, 1000개의 `라인번호: ...code...`가 있어도 모두 하나의 `...code...`로 통합합니다.
       * BEGIN~END 내부에 다른 제어 구조(IF, LOOP, CASE 등)가 있어도 모두 `...code...`로 축약합니다.
       * BEGIN~END 내부의 모든 내용은 완전히 제거하고 `...code...` 한 줄만 남깁니다.
       * 예: `BEGIN [주석/구분선/여러 ...code.../중첩 구조] END` → `BEGIN ...code... END`
  
  4. 포맷/스타일
     - 결과는 들여쓰기가 적용된 **단일 Oracle 코드 문자열**이어야 합니다.
     - 불필요한 주석/설명 금지. 백틱(```) 금지.
  
  
  [SECTION 3] PostgreSQL → Oracle 주요 변환 사항
  ===========================================
  1. CURSOR
     PostgreSQL: FOR rec IN (SELECT ...) LOOP
     Oracle: CURSOR cur IS SELECT ...; LOOP FETCH cur INTO ...
  
  2. 날짜 함수
     PostgreSQL: NOW() → Oracle: SYSDATE
     PostgreSQL: CURRENT_DATE → Oracle: SYSDATE
     PostgreSQL: CURRENT_TIMESTAMP → Oracle: SYSTIMESTAMP
  
  3. 문자열 함수
     PostgreSQL: COALESCE() → Oracle: NVL()
     PostgreSQL: SUBSTRING() → Oracle: SUBSTR()
  
  4. 기타
     - 자동 형변환 주의 (Oracle은 더 엄격)
     - EXCEPTION 블록 문법 동일
  
  
  [JSON 출력 형식]
  ===========================================
  부가 설명 없이, 아래 **정확한** JSON 형식으로만 반환하세요:
  {
     "code": "스켈레톤 코드 (시그니처 제외)"
  }
