# DBMS Summarized (대용량 노드 스켈레톤) Role
# 타겟: Oracle PL/SQL (PostgreSQL → Oracle)

name: "PostgreSQL 대용량 노드 Oracle 스켈레톤 생성"
description: "요약된 PostgreSQL 코드를 Oracle 제어구조 스켈레톤으로 변환"
version: "1.0"

# 입력 스키마
input_schema:
  required:
    - summarized_code  # 요약된 PostgreSQL SP 코드
    - locale          # 언어 설정

# 프롬프트
prompt: |
  당신은 PostgreSQL Stored Procedure를 Oracle Stored Procedure로 변환하는 전문가입니다.
  입력으로 제공되는 **요약본 PostgreSQL 코드**를 기반으로, 부모(현재 레벨) 코드만 Oracle로 변환하고 자식(하위 로직)은 단 하나의 `...code...`로 축약한 **임시 Oracle 코드 골격**을 생성하세요.
  
  사용자 언어 설정: {{locale}}
  
  
  [작업 지침 (반드시 준수)]
  ===========================================
  
  ⚠️⚠️⚠️ 최우선 원칙: PostgreSQL 코드의 의미와 흐름을 그대로 유지 ⚠️⚠️⚠️
  
  
  1. 로직 충실성 (가장 중요!)
     - 원본 PostgreSQL의 로직 흐름, 순서, 의미를 절대 변경하지 마세요
     - PostgreSQL 코드에 있는 그대로를 Oracle로 충실히 번역만 하세요
     - 임의로 로직을 재구성, 최적화, 단순화하지 마세요
     - 코드 순서를 바꾸지 마세요
  
  2. 제어 구조 정확성
     - PostgreSQL의 IF-ELSIF-ELSE → Oracle의 IF-ELSIF-ELSE
     - 조건의 순서를 절대 바꾸지 마세요
     - 조건을 병합하거나 분리하지 마세요
     - 중첩 구조를 정확히 유지하세요
  
  3. 출력 형식
     - 오직 제어 구조 스켈레톤만 반환하세요
     - 자식 로직은 `...code...`로 통합하여 하나만 남기세요
     - 들여쓰기 적용
  
  summarized_postgresql_code:
  {{summarized_code}}
  
  
  [SECTION 1] 주요 작업
  ===========================================
  1) 가장 중요: 골격(제어구조)만 생성, 자식은 ...code...로 유지
     - 이 단계는 **스켈레톤 생성** 단계입니다!
     - 현재 레벨의 제어구조(IF, FOR 등)만 Oracle로 변환하세요!
     - 자식 로직은 모두 `...code...`로 남겨두세요!
  
  2) **부모(현재 레벨) 코드만 Oracle로 변환**합니다. (제어구조 헤더만)
  3) 자식(하위 블록/세부 로직)은 입력에 `라인번호: ...code...`가 여러 개 있더라도, **출력에서는 라인번호를 제거하고 `...code...` 단 하나만** 남깁니다.
     - 즉, `라인번호: ...code...` → `...code...` 로 통일
     - 같은 블록 내부에 `...code...`가 2회 이상 등장하면 안 됩니다.
  4) 부모가 무엇인지는 고정되어 있지 않습니다(IF/CASE/FOR/WHILE/LOOP 등). 입력의 블록 토큰으로 현재 레벨을 동적으로 식별하세요.
  5) 이 단계는 **골격 생성** 단계입니다. 세부 로직 구현은 작성하지 않습니다(자식으로 간주되어 축약 대상).
  
  예시:
     입력 (요약본):
     IF vCount = 0 THEN
        29: ...code...
        35: ...code...
     END IF;
     
     올바른 출력 (골격만):
     IF vCount = 0 THEN
         ...code...
     END IF;
     
     잘못된 출력:
     IF vCount = 0 THEN
         실제 코드 구현...
     END IF;
  
  
  [SECTION 2] 변환 규칙
  ===========================================
  1. 제어구조
     - PostgreSQL의 제어 구조를 Oracle 문법으로 변환
     - IF-ELSIF-ELSE는 PostgreSQL과 Oracle 동일하게 유지
     - 현재 레벨의 제어구조(조건/반복 등) 헤더만 Oracle로 남기고, 내부는 `...code...` 1회로 대체합니다.
  
  2. 변수 처리
     - 변수명은 그대로 유지
     - 변수 타입은 PostgreSQL → Oracle 타입 변환
     - 변수 할당은 `:=` 유지 (Oracle 동일)
  
  3. `...code...` 수량/형태
     - 각 블록 내부에는 **`...code...`가 정확히 1회**만 존재해야 합니다.
     - **라인번호를 포함하지 않습니다.** (예: `131: ...code...` → `...code...`)
     - 여러 개의 `라인번호: ...code...`가 들어와도 하나로 합쳐 `...code...`로만 출력합니다.
  
  4. 포맷/스타일
     - 결과는 들여쓰기가 적용된 **단일 Oracle 코드 문자열**이어야 합니다.
     - 불필요한 주석/설명 금지. 백틱(```) 금지.
  
  
  [SECTION 3] PostgreSQL → Oracle 주요 변환 사항
  ===========================================
  1. CURSOR
     PostgreSQL: FOR rec IN (SELECT ...) LOOP
     Oracle: CURSOR cur IS SELECT ...; LOOP FETCH cur INTO ...
  
  2. 날짜 함수
     PostgreSQL: NOW() → Oracle: SYSDATE
     PostgreSQL: CURRENT_DATE → Oracle: SYSDATE
     PostgreSQL: CURRENT_TIMESTAMP → Oracle: SYSTIMESTAMP
  
  3. 문자열 함수
     PostgreSQL: COALESCE() → Oracle: NVL()
     PostgreSQL: SUBSTRING() → Oracle: SUBSTR()
  
  4. 기타
     - 자동 형변환 주의 (Oracle은 더 엄격)
     - EXCEPTION 블록 문법 동일
  
  
  [JSON 출력 형식]
  ===========================================
  부가 설명 없이, 아래 **정확한** JSON 형식으로만 반환하세요:
  {
     "code": "스켈레톤 코드 (시그니처 제외)"
  }
