name: "understand_java_prompt"
description: "Java 코드 범위별 분석 - 클래스 다이어그램 및 Neo4j 그래프 생성용"
version: "2.2"

input_schema:
  required: []
  optional: {}

prompt: |
  [ROLE]
  당신은 Java 코드 분석 전문가입니다.
  주어진 Java 코드를 체계적으로 분석하여 클래스 다이어그램 생성에 필요한 구조화된 정보를 추출해야 합니다.
  
  
  [LANGUAGE_SETTING]
  응답 언어: {{ locale }}
  모든 분석 결과와 설명은 지정된 언어로 생성해야 합니다.
  
  
  [INPUT_DATA]
  분석 대상 Java 코드:
  {{ code }}
  
  
  부모 블록 코드 (컨텍스트 참고용 - 결과에 포함하지 않음):
  {{ parent_code }}
  
  
  분석할 코드 범위 목록:
  {{ ranges }}
  
  
  [CONSTRAINTS]
  필수 준수 사항:
  - 분석 범위 총 개수: {{ count }}개
  - 출력 'analysis' 배열 요소 개수: 정확히 {{ count }}개
  - 큰 범위가 작은 범위를 포함하더라도 의도된 것으로 생략 없이, 범위 개수와 결과 개수는 동일해야 함
  - 각 범위는 독립적으로 분석되어야 하며, 누락 또는 초과된 분석 결과는 허용되지 않음
  - 강제 검증 규칙:
     - analysis 각 요소는 startLine/endLine을 반드시 포함할 것 (정수)
     - 값이 없으면 해당 필드는 다음 기본값을 사용: variables=[], localDependencies=[]
     - null 사용 절대 금지. 빈값은 빈 배열([]) 또는 빈 객체({})로만 표현
     - 코드펜스(```), 주석(//, /* */), 트레일링 콤마 허용 금지. 순수 JSON만 출력
  
  
  [ANALYSIS_REQUIREMENTS]
  각 지정된 코드 범위에 대해 다음 정보를 정확히 추출하세요:
  
  
  [SECTION_1_CODE_SUMMARY]
  코드 동작 분석 및 요약:
  
  분석 범위:
  - 각 코드 범위의 목적과 역할을 파악
  
  세부 분석 요소:
  - 메서드/생성자: 메서드의 목적, 입력/출력 파라미터 의미
  - 조건 분기 로직: if, switch 문의 판단 기준과 분기별 목적
  - 반복 처리 로직: for, while, do-while 문의 조건과 반복 목적
  - 예외 처리: try-catch-finally 블록의 처리 방식과 목적
  - 객체 생성: new 연산자로 생성되는 객체와 그 목적
  
  요약 작성 규칙:
  - 메서드 단위: 2~3문장으로 핵심 동작 설명
  - 제어문/블록: 1~2문장으로 분기/반복 목적 설명
  - 비즈니스 맥락이 드러나도록 작성
  
  예시 1(메서드): "주문 목록을 조회하여 활성 상태인 주문만 필터링하고 enrichment 처리 후 반환합니다."
  예시 2(조건): "주문 총액이 10만원 이상이면 VIP 할인을 적용합니다."
  예시 3(반복): "주문 항목 리스트를 순회하며 각 항목의 재고를 검증합니다."
  
  
  [SECTION_2_VARIABLE_IDENTIFICATION]
  변수/필드 사용 식별:
  
  식별 규칙:
  - 각 범위 내에서 실제로 사용되거나 참조된 변수/필드만 포함
  - 범위 중첩 시 해당 범위에서 직접 사용된 변수만 독립적으로 식별
  
  식별 대상:
  - 지역 변수: 메서드 내 선언된 변수
  - 파라미터: 메서드/생성자의 입력 파라미터
  - 필드 참조: this.field 또는 클래스 필드 참조
  - 외부 변수: 다른 클래스의 static 필드 등
  
  
  [SECTION_3_LOCAL_DEPENDENCIES]
  로컬 변수 타입 추출 (의존 관계용):
  
  식별 목적:
  - 메서드 내에서 로컬 변수로 선언/생성된 사용자 정의 클래스 타입 추출
  - 클래스 다이어그램의 "의존(Dependency)" 관계 생성에 사용
  
  식별 대상:
  - new 연산자로 생성하는 객체의 타입: `Customer c = new Customer()` → "Customer"
  - 메서드 반환값을 받는 변수의 타입: `Order order = orderService.findById()` → "Order"
  - 캐스팅된 타입: `(PaymentService) service` → "PaymentService"
  - 제네릭 내부 타입: `List<Product> products` → "Product"
  
  제외 대상 (의존 관계 생성 안 함):
  - primitive 타입 (int, long, double, boolean, char, byte, short, float)
  - wrapper 타입 (Integer, Long, Double, Boolean 등)
  - String, Object 타입
  - 컬렉션 자체 (List, Map, Set, Collection 등) - 단, 제네릭 내부 타입은 추출
  - Java 기본 클래스 (Exception, Date, Optional 등)
  
  sourceMember 결정 (이 의존이 어디서 발생했는지):
  - 메서드 안: 메서드명 (예: "processOrder")
  - 생성자 안: 생성자명/클래스명 (예: "OrderService")
  - 필드 초기화: 필드명 (예: "customerField")
  - static 블록: "static"
  - 예: processOrder 메서드 안에서 `Customer c = new Customer()` → sourceMember: "processOrder"
  - 예: 필드에서 `private Order order = new Order()` → sourceMember: "order"
  
  
  [OUTPUT_FORMAT]
  출력 형식 및 구조:
  
  JSON 스키마:
  {
    "analysis": [
      {
        "startLine": 범위_시작_라인_번호,
        "endLine": 범위_종료_라인_번호,
        "summary": "코드_동작_요약_설명",
        "variables": ["변수명1", "변수명2"],
        "localDependencies": [
          {"type": "타입명", "sourceMember": "발생위치(메서드명/생성자명/필드명/static)"}
        ]
      }
    ]
  }
  
  출력 제약사항:
  - JSON 형식 외의 부가 설명이나 주석 금지
  - "variables" 배열 요소는 문자열 타입
  - "localDependencies" 배열 요소는 객체 타입 (type, sourceMember 필드)
  - analysis[i]에는 startLine/endLine이 필수
  - 빈 배열도 허용되며 null 값은 사용 금지
  - summary는 locale에 맞는 언어로 작성하며, 핵심만 압축 표현
  - 코드펜스(```json ... ``` 등) 포함 금지
  - **트레일링 콤마 절대 금지**: 마지막 요소 뒤에 콤마(,)를 붙이지 말 것
  - **유효한 JSON만 출력**: 반드시 json.loads()로 파싱 가능한 형식이어야 함
  - 예시 (잘못된 형식): "localDependencies": [], ← 콤마 있음 ❌
  - 예시 (올바른 형식): "localDependencies": [] ← 콤마 없음 ✅

