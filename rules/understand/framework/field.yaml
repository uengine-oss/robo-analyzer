name: "field_prompt"
description: "Java 클래스의 필드(멤버 변수) 정보 추출 - 연관 관계(Association) 분석용"
version: "1.0"

input_schema:
  required:
    - declaration_code
  optional:
    locale:
      default: "ko"

prompt: |
  [ROLE]
  당신은 Java 코드에서 클래스의 필드(멤버 변수) 정보를 추출하는 전문가입니다.
  클래스 다이어그램에 표시할 필드 정보와 연관 관계(Association) 생성에 필요한 정보를 추출합니다.
  
  ⚠️ 책임 범위: 이 프롬프트는 구조적 소유 관계(합성/집합/연관) 판단만 담당합니다.
  
  
  [INPUT_DATA]
  분석 대상 Java 코드 (필드 선언부):
  {{ declaration_code }}
  
  
  [ANALYSIS_RULES]
  1. 모든 필드의 기본 정보 추출 (field_name, field_type, visibility 등)
  
  2. target_class 규칙 (연관 관계 대상만 설정, 그 외 null):
     - 설정 대상: 도메인/엔티티 타입, 서비스/리포지토리 타입, 컬렉션 내 도메인 타입
     - null로 설정: primitive 타입, wrapper 타입, String, Logger, 유틸리티 static 필드
     - ⚠️ 중요 제외: 값 객체(Value Object), enum, 식별자 전용 타입은 target_class로 설정하지 않는다
       예: Money, Address, Email, OrderId, Status(enum) 등은 null로 설정
       이유: 이들은 관계가 아닌 속성/값으로 취급되어야 함
  
  3. 연관 관계 타입 판단 (target_class가 있을 때만)
     
     ⚠️ 핵심 원칙: 로직(코드 구현)이 아니라 도메인 의미로 판단합니다.
     
     도메인 의미란?
     - 코드가 어떻게 돌아가느냐가 아니라, 객체가 무엇을 표현하느냐
     - 현실 세계 또는 문제 영역에서 그 개념이 어떤 존재인가
     - 구현 세부사항(new, 생성자, final 등)이 아니라 개념의 본질
     
     판단 기준: "이 객체를 떼어낼 수 있느냐" 하나로 판단
     
     질문 ①: "이건 저 객체의 '부품'이라고 말해도 자연스러운가?"
        - 도메인 개념상 전체-부분 관계인가?
        - 현실 세계에서 "A의 B"라고 표현하는 것이 자연스러운가?
        - 예: "플레이어의 퀘스트 로그" → 자연스러움
        - 예: "주문의 금액" → 자연스럽지 않음 (값이지 부품 아님)
        ✘ NO → 연관(ASSOCIATION) 또는 속성 (관계 아님)
        ✔ YES → 다음 질문
     
     질문 ②: "주인 객체가 없어지면, 이 객체는 의미가 남는가?"
        - 도메인 개념상 독립적인 존재인가?
        - 주인 없이도 그 자체로 의미가 있는가?
        - 예: "플레이어 없이 퀘스트 로그" → 의미 없음
        - 예: "인벤토리 없이 아이템" → 의미 있음 (아이템은 독립 존재)
        ✔ YES → 집합(AGGREGATION) 또는 연관(ASSOCIATION)
        ✘ NO → 다음 질문
     
     질문 ③: "이 객체를 다른 객체로 옮겨도 말이 되는가?"
        - 도메인 개념상 이동/교체 가능한가?
        - 다른 소유자에게 옮겨도 의미가 유지되는가?
        - 예: "퀘스트 로그를 다른 플레이어로" → 말이 안 됨
        - 예: "아이템을 다른 인벤토리로" → 말이 됨
        ✔ YES → 집합(AGGREGATION) 또는 연관(ASSOCIATION)
        ✘ NO → 합성(COMPOSITION)
     
     한 줄 공식: 못 떼면 합성, 떼면 집합, 애매하면 연관
     
     관계 타입별 의미 (도메인 관점):
     - COMPOSITION (합성, ◆): 내부 부품. 주인이 없으면 의미 없음. 다른 곳으로 이동 불가
       특징: 도메인 개념상 전체의 일부, 생명주기 종속, 이동 불가
       예시:
         - Player의 QuestLog (플레이어 없으면 퀘스트 로그 의미 없음)
         - GameMap의 MapTile (맵 없으면 타일 의미 없음)
         - Order의 OrderLine (주문 없으면 주문 항목 의미 없음)
           ※ 단, OrderLine을 독립 엔티티로 취급하는 도메인에서는 집합 또는 연관이 될 수 있음
         - Document의 Paragraph (문서 없으면 문단 의미 없음)
     
     - AGGREGATION (집합, ◇): 같이 쓰는 것. 독립 존재 가능. 다른 곳으로 이동 가능
       특징: 도메인 개념상 독립 존재, 생명주기 독립, 이동 가능
       예시:
         - Inventory의 Item (인벤토리 없어도 아이템 존재 가능, 다른 인벤토리로 이동 가능)
         - Team의 Player (팀 해체돼도 플레이어 존재, 다른 팀으로 이동 가능)
         - ShoppingCart의 Product (장바구니 없어도 상품 존재, 다른 장바구니로 이동 가능)
         - Library의 Book (도서관 없어도 책 존재, 다른 도서관으로 이동 가능)
     
     - ASSOCIATION (연관, —): 그냥 알고 있음. 생명주기/소유 강제 없음
       특징: 단순 참조 관계, 명확한 소유 관계 아님, 애매할 때 안전한 선택
       예시:
         - Player의 Weapon (단순 참조, 명확하지 않을 때 안전한 선택)
         - Order의 Customer (주문과 고객은 단순 참조 관계)
         - Student의 Course (학생과 강의는 참조 관계)
     
     ⚠️ 로직은 힌트일 뿐, 결정 기준 아님:
     - new로 생성했다고 합성 아님 (도메인 의미로 판단)
       예: this.questLog = new QuestLog(); → 도메인 의미상 합성 (Player의 부품)
       예: this.item = new Item(); → 도메인 의미상 집합일 수도 있음 (독립 객체)
     
     - 생성자/세터로 주입받았다고 집합 아님 (도메인 의미로 판단)
       예: this.inventory = inventory; → 도메인 의미상 집합 (독립 객체)
       예: this.questLog = questLog; → 도메인 의미상 합성일 수도 있음 (Player의 부품)
     
     - List<T>라고 집합 아님 (도메인 의미로 판단)
       예: List<Item> items; → 도메인 의미상 집합 (독립 객체들)
       예: List<MapTile> tiles; → 도메인 의미상 합성일 수도 있음 (맵의 구성요소)
     
     - final, private 등 접근 제어자도 결정 기준 아님
     
     판단 예시:
     예시 1: private QuestLog questLog;
       - 질문 ①: QuestLog는 Player의 부품인가? → ✔ YES ("플레이어의 퀘스트 로그")
       - 질문 ②: Player 없이 QuestLog 의미 있나? → ✘ NO
       - 질문 ③: QuestLog를 다른 Player로 옮기나? → ✘ NO
       - 최종 판단: COMPOSITION (합성)
     
     예시 2: private List<Item> items;
       - 질문 ①: Item은 Inventory의 부품인가? → ✔ YES ("인벤토리의 아이템")
       - 질문 ②: Inventory 없이 Item 의미 있나? → ✔ YES (아이템은 독립 존재)
       - 질문 ③: Item을 다른 Inventory로 옮기나? → ✔ YES (가능)
       - 최종 판단: AGGREGATION (집합)
     
     예시 3: private Weapon weapon;
       - 질문 ①: Weapon은 Player의 부품인가? → 애매함
       - 질문 ②: Player 없이 Weapon 의미 있나? → ✔ YES (무기는 독립 존재)
       - 질문 ③: Weapon을 다른 Player로 옮기나? → ✔ YES (가능)
       - 최종 판단: ASSOCIATION (연관) - 애매하므로 안전한 선택
     
     ⚠️ 헷갈리면 연관(ASSOCIATION) 선택 (가장 안전)
  
  5. 다중성 (multiplicity)
     - 1: 단일 객체 참조
     - *: 배열/컬렉션(List, Set, Map 등)
  
  
  [OUTPUT_FORMAT]
  JSON 형식으로만 결과를 반환:
  {
    "fields": [
      {
        "field_name": "필드명",
        "field_type": "전체 타입명 (제네릭 포함)",
        "target_class": "연관 대상 타입명 또는 null",
        "visibility": "public | private | protected | default",
        "is_static": true | false,
        "is_final": true | false,
        "multiplicity": "1 | *",
        "association_type": "ASSOCIATION | AGGREGATION | COMPOSITION | null",
        "association_reason": "판단 근거 (선택, 디버깅용): cannot_detach_domainwise | independent_entity | ambiguous | value_object"
      }
    ]
  }
  
  출력 제약:
  - JSON만 출력 (코드펜스 금지)
  - 모든 필드 정보 반환 (primitive/String 포함)
  - target_class가 null이면 association_type도 null
  - association_reason는 선택 필드 (디버깅/검증용, null 가능)

