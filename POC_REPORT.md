# PostgreSQL → Oracle DBMS 변환 POC 보고서

> **Proof of Concept (POC)**: PostgreSQL 저장 프로시저를 Oracle PL/SQL로 자동 변환하는 개념 증명 프로젝트

**작성일**: 2025-01-XX  
**버전**: 1.0.0  
**프로젝트**: Legacy Modernizer - DBMS 변환 모듈

---

## 목차

1. [POC 개요](#1-poc-개요)
2. [진행 방법](#2-진행-방법)
3. [시스템 아키텍처](#3-시스템-아키텍처)
4. [검증 결과](#4-검증-결과)
5. [향후 방향](#5-향후-방향)

---

## 1. POC 개요

### 1.1 목적

PostgreSQL 저장 프로시저(Stored Procedure)를 Oracle PL/SQL로 자동 변환하는 기술의 실현 가능성을 검증하고, 변환 품질과 정확도를 평가하는 것이 본 POC의 목적입니다.

### 1.2 배경

- **레거시 시스템 현대화**: PostgreSQL 기반 레거시 시스템을 Oracle 환경으로 마이그레이션
- **수동 변환의 한계**: 대규모 저장 프로시저 코드베이스를 수동으로 변환하는 것은 시간과 비용이 과다
- **자동화 필요성**: AI 기반 자동 변환 도구를 통한 효율적인 마이그레이션 프로세스 구축

### 1.3 범위

- **입력**: PostgreSQL 저장 프로시저 코드 (`.sql` 파일)
- **출력**: Oracle PL/SQL 코드 (`.sql` 파일)
- **프로세스**: ANTLR 파싱 → 그래프 표현 → LLM 기반 변환

---

## 2. 진행 방법

### 2.1 전체 타임라인

```
0주차 ────────────────────────────────────────────────────────── 4주차
│
├─ 0~1주차: PostgreSQL 문법 파일 작성 및 AST 추출
├─ 1~2주차: AST → Understanding 그래프 변환
├─ 2~3주차: 그래프 기반 Oracle 변환 및 지침 강화
└─ 3~4주차: 복잡 구문 분할 처리 및 정확도 개선
```

### 2.2 0~1주차: PostgreSQL 문법 파일 작성 및 AST 추출

#### 목표
PostgreSQL 전용 저장 프로시저 코드를 파싱하여 AST(Abstract Syntax Tree) 구조를 추출

#### 작업 내용
- **ANTLR 문법 파일 작성**: PostgreSQL 저장 프로시저 전용 `.g4` 문법 파일 개발
  - 세밀한 파싱 구조 대신 **덩어리 단위 파싱** 전략 채택
  - 예: `UPDATE` 문 내부의 복잡한 `SELECT` 서브쿼리를 하나의 `UPDATE` 노드로 처리
  - 디테일한 파싱을 위해서는 약 1만 라인 규모의 문법 파일이 필요하나, POC 단계에서는 단순화된 구조로 진행

#### 성과
- ✅ PostgreSQL SP 코드 파싱 성공
- ✅ AST JSON 구조 생성 완료
- ✅ 문법 파일 기반 파서 동작 검증

#### 기술 스택
- **ANTLR4 (Java)**: Java 기반 파서 생성 도구, PostgreSQL SP 코드를 AST JSON으로 변환

---

### 2.3 1~2주차: AST → Understanding 그래프 변환

#### 목표
AST 구조를 Neo4j 그래프 데이터베이스로 변환하여 코드의 구조와 관계를 시각화

#### 작업 내용
- **AST 수집**: AST JSON을 후위순회하여 노드 리스트 생성
- **Neo4j 그래프 생성**:
  - **노드 타입**: PROCEDURE, SELECT, INSERT, UPDATE, DELETE, IF, LOOP, Table, Column, Variable 등
  - **관계 타입**: 
    - `PARENT_OF`: AST 부모-자식 관계
    - `NEXT`: 실행 순서 관계
    - `FROM`: SELECT와 Table 간 읽기 관계
    - `WRITES`: INSERT/UPDATE/DELETE와 Table 간 쓰기 관계
    - `CALL`: 프로시저 호출 관계
    - `HAS_COLUMN`: Table과 Column 관계
- **LLM 기반 분석**: 
  - 코드 요약(`summary`)
  - 변수 사용 정보
  - 테이블/컬럼 메타데이터 추출
  - 프로시저 호출 관계 파악

#### 성과
- ✅ AST → Neo4j 그래프 변환 성공
- ✅ 테이블, 임시테이블, DML 관계 그래프 표현 완료
- ✅ 프로시저 호출 관계 시각화 완료
- ✅ 그래프 기반 코드 구조 분석 가능

#### 기술 스택
- **Neo4j**: 그래프 데이터베이스
- **LLM (pGPT)**: 코드 의미 분석
- **Python (FastAPI)**: 백엔드 API

---

### 2.4 2~3주차: 그래프 기반 Oracle 변환 및 지침 강화

#### 목표
Neo4j 그래프를 활용하여 실제 Oracle PL/SQL 코드로 변환하고, 변환 정확도를 높이기 위한 지침 강화

#### 작업 내용
- **Converting 파이프라인 구축**:
  - Oracle 프로시저 스켈레톤 생성 (PROCEDURE 헤더, DECLARE 섹션)
  - 본문 로직 변환
    - 토큰 기반 배치 처리 (1000 토큰 임계값)
    - 대용량 노드(토큰 ≥ 1000)는 스켈레톤 방식으로 처리
    - 소형 노드는 누적 후 LLM 변환
  - 프롬프트 규칙 기반 변환 적용
    - 스켈레톤 생성 규칙
    - 본문 변환 규칙
    - 대용량 노드 요약 규칙

- **지침 강화 작업**:
  - PostgreSQL → Oracle 문법 매핑 규칙 정립
  - LLM 프롬프트 개선을 통한 변환 정확도 향상 시도

#### 문제점
- ❌ **컴파일 오류 발생**: 변환된 Oracle 코드가 문법 오류로 인해 실행 불가능
- ❌ **정확도 저하**: 변환 품질이 기대 수준에 미치지 못함
- ❌ **복잡한 구문 처리 실패**: 중첩된 서브쿼리, 복잡한 조건문 등에서 오류 발생

#### 기술 스택
- **Neo4j Cypher**: 그래프 쿼리
- **LLM (pGPT)**: 코드 변환
- **프롬프트 규칙**: 변환 규칙 정의

---

### 2.5 3~4주차: 복잡 구문 분할 처리 및 정확도 개선

#### 목표
복잡한 구문을 수동으로 분할하여 그래프로 표현한 후 변환 정확도를 개선

#### 작업 내용
- **복잡 구문 분할 전략**:
  - LLM이 변환하기 어려운 복잡한 구문 식별
  - 수동으로 구조를 나눠서 그래프 노드로 분할
  - 분할된 노드를 개별적으로 변환 후 병합
- **지침 지속 강화**:
  - 변환 실패 사례 분석
  - 프롬프트 및 규칙 파일 개선
  - 토큰 임계값 조정 및 배치 전략 최적화

#### 성과
- ✅ 복잡 구문 분할 처리 메커니즘 구축
- ✅ 수동 분할을 통한 변환 정확도 부분 개선
- ⚠️ 여전히 컴파일 오류 및 정확도 문제 존재

---

## 3. 시스템 아키텍처

### 3.1 전체 아키텍처 개요

```
┌─────────────────────────────────────────────────────────────────┐
│                    PostgreSQL SP 코드 (.sql)                     │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                         ANTLR 파서                                │
│  - PostgreSQL 전용 .g4 문법 파일                                  │
│  - 덩어리 단위 파싱 (세밀한 파싱 생략)                            │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                      AST JSON 구조                                │
│  {                                                               │
│    "type": "PROCEDURE",                                         │
│    "startLine": 1,                                               │
│    "endLine": 100,                                               │
│    "children": [...]                                             │
│  }                                                               │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Backend 서버                                    │
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              Understanding 파이프라인                      │  │
│  │  - AST 수집: AST → 노드 리스트                             │  │
│  │  - Neo4j 그래프 생성                                       │  │
│  │  - LLM 분석: 코드 요약, 테이블/컬럼 추출                   │  │
│  └────────────────────────────┬───────────────────────────────┘  │
│                               │                                   │
│  ┌────────────────────────────▼───────────────────────────────┐  │
│  │              Converting 파이프라인                           │  │
│  │  - Oracle 스켈레톤 생성                                    │  │
│  │  - 본문 로직 변환                                           │  │
│  │  - 프롬프트 규칙 기반 변환                                  │  │
│  └────────────────────────────┬───────────────────────────────┘  │
└────────────────────────────────┼───────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Neo4j Graph Database                          │
│  - 노드: PROCEDURE, SELECT, INSERT, Table, Column, Variable    │
│  - 관계: PARENT_OF, NEXT, FROM, WRITES, CALL, HAS_COLUMN        │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Oracle PL/SQL 코드 (.sql)                      │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 Understanding 파이프라인 상세

#### 3.2.1 AST 수집 단계

AST JSON을 후위순회하여 노드 리스트를 생성합니다.

**입력**: ANTLR JSON  
**출력**: 노드 리스트 (라인 범위, 노드 타입, 코드 포함)

#### 3.2.2 그래프 생성 단계

1. 정적 노드 생성 (FILE, PROCEDURE, SELECT 등)
2. 관계 생성 (PARENT_OF, NEXT)
3. LLM 분석 및 속성 업데이트

**Neo4j 노드 생성**:
- `PROCEDURE`: 저장 프로시저
- `SELECT`, `INSERT`, `UPDATE`, `DELETE`: DML 구문
- `Table`, `Column`: 데이터베이스 스키마
- `Variable`: 변수 선언

**Neo4j 관계 생성**:
- `PARENT_OF`: AST 부모-자식 관계
- `NEXT`: 실행 순서
- `FROM`: SELECT → Table (읽기)
- `WRITES`: INSERT/UPDATE/DELETE → Table (쓰기)
- `CALL`: 프로시저 호출

### 3.3 Converting 파이프라인 상세

#### 3.3.1 스켈레톤 생성 단계

Neo4j 그래프에서 PROCEDURE, SPEC, DECLARE 정보를 조회하여 LLM으로 Oracle 스켈레톤을 생성합니다.

**입력**: Neo4j 그래프 (PROCEDURE, SPEC, DECLARE 노드)  
**출력**: Oracle 프로시저 스켈레톤 (헤더 + DECLARE 섹션 + 코드 플레이스홀더)

#### 3.3.2 본문 변환 단계

Neo4j 그래프에서 변환 대상 노드를 조회하여 토큰 기반 배치 처리를 수행합니다.

- 토큰 기반 배치 처리
- 대용량 부모 노드(토큰 ≥ 1000): 스켈레톤 생성
- 소형 노드: 누적 후 변환
- 토큰 누적이 1000 이상이면 LLM 변환 실행

**변환 전략**:
1. **토큰 임계값**: 1000 토큰 기준으로 배치 분할
2. **대용량 노드**: 토큰 ≥ 1000이고 자식이 있는 경우 → 스켈레톤 생성 후 자식 코드 주입
3. **소형 노드**: 토큰 < 1000 → 누적 후 일괄 변환
4. **부모 스택 관리**: 중첩된 구조를 스택으로 관리하여 최종 병합

**변환 규칙**:
- 본문 변환 프롬프트
- 대용량 노드 요약 프롬프트

### 3.4 데이터 흐름

```
PostgreSQL SP 코드
    │
    ├─→ ANTLR 파서 → AST JSON
    │
    ├─→ Understanding 파이프라인
    │   ├─ AST 수집: AST → 노드 리스트
    │   ├─ Neo4j 그래프 생성
    │   └─ LLM 분석: 코드 요약, 메타데이터 추출
    │
    └─→ Neo4j Graph Database
        │
        └─→ Converting 파이프라인
            ├─ 스켈레톤 생성
            ├─ 본문 변환
            └─ 프롬프트 규칙 적용
                │
                └─→ Oracle PL/SQL 코드
```

---

## 4. 검증 결과

### 4.1 성공 사항

#### ✅ AST 추출 성공
- PostgreSQL SP 코드를 ANTLR로 파싱하여 AST JSON 생성 성공

#### ✅ 그래프 변환 성공
- AST → Neo4j 그래프 변환 완료
- 테이블, 컬럼, DML 관계 시각화 성공
- 프로시저 호출 관계 파악 가능

#### ✅ 변환 파이프라인 구축
- Understanding → Converting 파이프라인 완성
- 토큰 기반 배치 처리 메커니즘 동작
- 스켈레톤 + 본문 병합 로직 구현

### 4.2 문제점 및 한계

#### ❌ 컴파일 오류 발생
- **문제**: 변환된 Oracle 코드가 문법 오류로 인해 컴파일 실패
- **원인**:
  - PostgreSQL과 Oracle 간 문법 차이를 LLM이 완벽히 처리하지 못함
  - 복잡한 서브쿼리, 윈도우 함수, 특수 문법 변환 실패
  - 변수 타입, 스키마 참조 등 컨텍스트 정보 부족

#### ❌ 변환 정확도 저하
- **문제**: 변환 품질이 기대 수준에 미치지 못함
- **원인**:
  - postgresql과 oracle의 구조적 차이 문제로 정확한 전환이 어려움
  - LLM 프롬프트만으로는 충분한 변환 규칙 전달 어려움
  - 복잡한 비즈니스 로직의 의미 보존 실패

#### ❌ 복잡 구문 처리 한계
- **문제**: Converting은 복잡한 서브쿼리, 중첩 구조를 변환하지 못함
- **핵심 발견**: 코드 길이는 중요하지 않고 **복잡도가 큰 영향을 주는 것으로 확인**
  - 단순한 긴 코드는 변환 가능하나, 복잡한 중첩 구조는 변환 실패
- **피드백 루프 시도 및 실패**:
  - 피드백 루프를 시도했으나 컴파일 오류를 잡는데에만 집중하고 의미를 뭉개버림
  - 프롬프트 규칙을 수정해도 복잡한 구문을 완벽히 전환하는 것은 불가능함을 확인
  - **결론**: 피드백 루프 접근법은 취소
- **최종 해결 방향**: 복잡한 구문을 쪼개서 병합하는 방식으로 진행

### 4.3 개선 노력

#### 지침 강화 시도
- 프롬프트 규칙 지속 개선 시도
- LLM 프롬프트 정밀화 시도
- 변환 실패 사례 분석 및 반영 시도
- **결과**: 복잡한 구문의 완벽한 전환은 불가능함을 확인

#### 피드백 루프 시도 및 한계
- 피드백 루프를 통해 컴파일 오류 수정 시도
- **문제점**: 컴파일 오류를 잡는데 집중하다 보니 코드의 의미가 손실됨
- **결론**: 피드백 루프 접근법은 효과적이지 않아 취소

#### 복잡 구문 분할 전략 (최종 방향)
- 복잡한 구문을 수동으로 구조를 나눠서 그래프 노드로 분할
- 분할된 노드를 개별적으로 변환 후 병합
- 쪼개서 병합하는 방식으로 진행하여 부분적 정확도 개선 달성
- **결과**: 컴파일 오류는 해결되었으나 실행 결과 불일치 문제 발생

### 4.4 현재 결과

#### ⚠️ 실행 결과 불일치
- **상황**: 간단한 수정으로 컴파일 오류는 해결되고 실행까지 되지만, **실행 결과가 완전히 불일치한 상황**
- **대상 프로시저**:
  - `usp_cc_flex_predict_insert`: 3,570라인 (복잡한 중첩 구조의 서브쿼리)
  - `month_insert_steel_pcode`: 6,506라인


---

## 5. 향후 방향

### 5.1 핵심 과제

#### 5.1.1 구조적 차이 극복
- **목표**: PostgreSQL과 Oracle의 구조적 차이를 극복할 수 있는 정보를 지침에 추가
- **현황**: 구조적 차이를 어떻게 극복할 수 있는지에 대한 명확한 방법론 부재
- **방향**: 지속적인 연구와 개선을 통해 구조적 차이를 해결할 수 있는 방안 모색

#### 5.1.2 실행 결과 일치성 확보
- **목표**: 변환된 Oracle 코드의 실행 결과가 원본 PostgreSQL 코드와 동일하게 동작하도록 보장
- **현황**: 실행 결과를 동일하게 만드는 구체적인 방법론 부재
- **방향**: 실행 결과 검증 메커니즘 개발 및 변환 품질 향상 방안 연구

### 5.2 개선 방향

#### 5.2.1 프롬프트 규칙 개선
- PostgreSQL과 Oracle 간 구조적 차이를 반영한 프롬프트 규칙 지속 개선
- 변환 실패 사례 분석을 통한 규칙 보강
- 실행 결과 불일치 원인 분석 및 규칙에 반영

#### 5.2.2 복잡도 기반 처리 전략
- 복잡도 측정 지표 개발
- 복잡한 중첩 구조에 대한 분할 전략 고도화
- 분할 후 병합 시 의미 보존 로직 강화

#### 5.2.3 검증 및 테스트 강화
- 변환된 코드의 실행 결과 검증 메커니즘 구축
- 자동화된 테스트 케이스 개발
- 실행 결과 비교 도구 개발


